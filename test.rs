#![feature(prelude_import)]
#![feature(structural_match)]
#![feature(box_syntax)]
#![no_std]
//! The main program file. Contains the main function and ties together all the submodules.
//!
//! Note regarding documentation: Rust does not currently support documentation on items
//! generated by macros, so many functions in this module are undocumented. Read the source
//! code to see a few notes on these items.

#![feature(box_patterns)]
#![feature(plugin)]
#![plugin(phf_macros)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
#[macro_use]
extern crate nom;
extern crate phf;

use nom::{multispace, alpha, alphanumeric, IResult, InputLength};

use std::str;
use std::fmt;
use std::io;
use std::io::Write;

pub mod rational {


    // a Box is an owned pointer (a function is not a concrete type)
    // the function takes an f64 and returns an f64 (f64 is a double)
    // a Vec is like an ArrayList


    // Call Expression::Value on a successful result or call Expression::Error on error

    // call the from_input method to convert rather than from_float



    // this does not convert to approximate floats as rational numbers

    // functions cannot be compared, so we assume that they're not equal.


    // a Value is printed as is
    // Error does not have a Display implementation yet

    // Expression methods

    // TODO: move functions into function module


    // unary functions first
    // multi-argument functions






    // either an expression in parentheses
    // or a function name followed by parentheses and comma-separated arguments



    // Remove underscores
    // then interpret as a float





    // e.g. 1/2pi => 1/(2pi), but 1/2 pi => pi/2








    // the following tests are self-explanatory.








    // Rust reference examples



    // REPL
    // TODO: move to separate function
    // add a question mark to end the end of the input
    //! Rational number module.
    #[prelude_import]
    use std::prelude::v1::*;
    use std::ops::Neg;
    use std::cmp;
    use std::cmp::Ord;
    use std::fmt;
    /// Rational numbers. The following are invariants:
    ///
    /// * Both numerator and denominator are between `i32::min_value() + 1`
    ///   and `i32::max_value()`, inclusive. (This is so that negation and
    ///   casting between `i32` and `u32` are always valid.) Any operation
    ///   that would cause this to be false would return `Err(OverflowError)`.
    /// * The denominator is always positive. An operation that would
    ///   cause the denominator to be zero would return `Err(OverflowError)`.
    #[structural_match]
    pub struct Rational {
        /// Simplified numerator
        pub num: i32,
        /// Simplified denominator
        pub den: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Rational {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match *self {
                Rational { num: ref __self_0_0, den: ref __self_0_1 } => {
                    (*__self_0_0).assert_receiver_is_total_eq();
                    (*__self_0_1).assert_receiver_is_total_eq();
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Rational {
        #[inline]
        fn eq(&self, __arg_0: &Rational) -> bool {
            match *__arg_0 {
                Rational { num: ref __self_1_0, den: ref __self_1_1 } =>
                match *self {
                    Rational { num: ref __self_0_0, den: ref __self_0_1 } =>
                    true && (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &Rational) -> bool {
            match *__arg_0 {
                Rational { num: ref __self_1_0, den: ref __self_1_1 } =>
                match *self {
                    Rational { num: ref __self_0_0, den: ref __self_0_1 } =>
                    false || (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Rational {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                Rational { num: ref __self_0_0, den: ref __self_0_1 } => {
                    let mut builder = __arg_0.debug_struct("Rational");
                    let _ = builder.field("num", &&(*__self_0_0));
                    let _ = builder.field("den", &&(*__self_0_1));
                    builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::hash::Hash for Rational {
        fn hash<__H: ::std::hash::Hasher>(&self, __arg_0: &mut __H) -> () {
            match *self {
                Rational { num: ref __self_0_0, den: ref __self_0_1 } => {
                    ::std::hash::Hash::hash(&(*__self_0_0), __arg_0);
                    ::std::hash::Hash::hash(&(*__self_0_1), __arg_0);
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Rational {
        #[inline]
        fn clone(&self) -> Rational {
            match *self {
                Rational { num: ref __self_0_0, den: ref __self_0_1 } => {
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_0));
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_1));
                    *self
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Rational { }
    /// An operation caused a value to overflow
    #[structural_match]
    pub struct OverflowError;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for OverflowError {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match *self { OverflowError => { } }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for OverflowError {
        #[inline]
        fn eq(&self, __arg_0: &OverflowError) -> bool {
            match *__arg_0 {
                OverflowError => match *self { OverflowError => true, },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for OverflowError {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                OverflowError => {
                    let mut builder = __arg_0.debug_tuple("OverflowError");
                    builder.finish()
                }
            }
        }
    }
    /// Exponentiation, but also check for integer overflow.
    #[inline]
    fn checked_pow(mut base: i32, mut exp: u32)
     -> Result<i32, OverflowError> {
        let mut acc: i32 = 1;
        while exp > 1 {
            if (exp & 1) == 1 {
                acc =
                    match acc.checked_mul(base).ok_or(OverflowError) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
            }
            exp /= 2;
            base =
                match base.checked_mul(base).ok_or(OverflowError) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
        }
        if exp == 1 {
            acc =
                match acc.checked_mul(base).ok_or(OverflowError) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
        }
        Ok(acc)
    }
    /// Find the greatest common divisor of two integers.
    /// The result has the same sign as the denominator `n`, or the sign
    /// of the numerator `m` if it is zero.
    /// Copied from [`num`](https://github.com/rust-num/num) crate
    /// (MIT/Apache License).
    #[inline]
    fn gcd(mut m: i32, mut n: i32) -> i32 {
        if m == 0 || n == 0 { return m | n }
        let shift = (m | n).trailing_zeros();
        if m == i32::min_value() || n == i32::min_value() {
            return (1 << shift) as i32
        }
        let n_sign = n.signum();
        m = m.abs();
        n = n.abs();
        n >>= n.trailing_zeros();
        while m != 0 {
            m >>= m.trailing_zeros();
            if n > m { ::std::mem::swap(&mut n, &mut m) }
            m -= n;
        }
        (n << shift) * n_sign
    }
    /// A trait for values that can be checked so that it satisfies the Rational invariant against
    /// overflow.
    trait CheckableOverflow<T> {
        fn check_overflow(self)
        -> Result<T, OverflowError>;
    }
    /// Check numerator and denominator for overflow
    impl CheckableOverflow<Rational> for Rational {
        #[inline]
        fn check_overflow(self) -> Result<Rational, OverflowError> {
            if self.num > i32::min_value() && self.den > 0 &&
                   self.den <= (i32::max_value() as u32) {
                Ok(self)
            } else { Err(OverflowError) }
        }
    }
    /// Check an unsigned int for overflow
    impl CheckableOverflow<u32> for u32 {
        #[inline]
        fn check_overflow(self) -> Result<u32, OverflowError> {
            if self > 0 && self <= (i32::max_value() as u32) {
                Ok(self)
            } else { Err(OverflowError) }
        }
    }
    /// Check a signed int for overflow
    impl CheckableOverflow<i32> for i32 {
        #[inline]
        fn check_overflow(self) -> Result<i32, OverflowError> {
            if self > i32::min_value() {
                Ok(self)
            } else { Err(OverflowError) }
        }
    }
    /// Check a result of a checkable type
    impl <T, U> CheckableOverflow<U> for Result<T, OverflowError> where
     T: CheckableOverflow<U> {
        #[inline]
        fn check_overflow(self) -> Result<U, OverflowError> {
            self.and_then(CheckableOverflow::check_overflow)
        }
    }
    /// Rationals are easily negated
    impl Neg for Rational {
        type
        Output
        =
        Rational;
        #[inline]
        fn neg(self) -> Rational { Rational{num: -self.num, den: self.den,} }
    }
    /// Format a rational as a string (integers are written as-is)
    impl fmt::Display for Rational {
        fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
            if self.den == 1 {
                f.write_fmt(::std::fmt::Arguments::new_v1({
                                                              static __STATIC_FMTSTR:
                                                                     &'static [&'static str]
                                                                     =
                                                                  &[""];
                                                              __STATIC_FMTSTR
                                                          },
                                                          &match (&self.num,)
                                                               {
                                                               (__arg0,) =>
                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                            ::std::fmt::Display::fmt)],
                                                           }))
            } else {
                f.write_fmt(::std::fmt::Arguments::new_v1({
                                                              static __STATIC_FMTSTR:
                                                                     &'static [&'static str]
                                                                     =
                                                                  &["", "/"];
                                                              __STATIC_FMTSTR
                                                          },
                                                          &match (&self.num,
                                                                  &self.den) {
                                                               (__arg0,
                                                                __arg1) =>
                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                            ::std::fmt::Display::fmt),
                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                            ::std::fmt::Display::fmt)],
                                                           }))
            }
        }
    }
    impl Rational {
        /// Zero rational
        #[inline]
        pub fn zero() -> Rational { Rational{num: 0, den: 1,} }
        /// Rational from an integer (need to check if it's outside Rational range)
        #[inline]
        pub fn from_integer(i: i32) -> Result<Rational, OverflowError> {
            Ok(Rational{num:
                            match i.check_overflow() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            },
                        den: 1,})
        }
        /// Create a Rational from numerator and denominator, and simplify
        pub fn new(num: i32, den: i32) -> Result<Rational, OverflowError> {
            if den == 0 {
                {
                    ::std::rt::begin_unwind("denominator = 0",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src\\rational.rs",
                                                     182u32);
                                                &_FILE_LINE
                                            })
                };
            }
            let gcd = gcd(num, den);
            Rational{num: num / gcd,
                     den: (den / gcd) as u32,}.check_overflow()
        }
        /// Negate and return the result.
        #[inline]
        pub fn negate(&self) -> Rational {
            Rational{num: -self.num, den: self.den,}
        }
        /// Find the reciprocal (1/0 returns OverflowError)
        #[inline]
        pub fn recip(&self) -> Result<Rational, OverflowError> {
            if self.num > 0 {
                Ok(Rational{num: self.den as i32, den: self.num as u32,})
            } else {
                if self.num != 0 {
                    Ok(Rational{num: -(self.den as i32),
                                den: (-self.num) as u32,})
                } else { Err(OverflowError) }
            }
        }
        /// Check if integer (denominator = 1)
        #[inline]
        pub fn is_integer(&self) -> bool { self.den == 1 }
        /// Check if zero (numerator = 0)
        #[inline]
        pub fn is_zero(&self) -> bool { self.num == 0 }
        /// Check if it is one
        #[inline]
        pub fn is_one(&self) -> bool { self.num == 1 && self.den == 1 }
        /// Check if it is negative
        #[inline]
        pub fn is_negative(&self) -> bool { self.num < 0 }
        /// Take the 'exp'th power
        #[inline]
        pub fn pow(&self, exp: i32) -> Result<Rational, OverflowError> {
            if exp != 0 {
                if exp > 0 {
                    Rational{num:
                                 match checked_pow(self.num, exp as u32) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 },
                             den:
                                 match checked_pow(self.den as i32,
                                                   exp as u32) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 } as u32,}.check_overflow()
                } else {
                    if exp != i32::min_value() {
                        match self.pow(-exp) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }.recip()
                    } else {
                        if (self.num == 1 || self.num == -1) && self.den == 1
                           {
                            Ok(Rational{num: 1, den: 1,})
                        } else { Err(OverflowError) }
                    }
                }
            } else { Ok(Rational{num: 1, den: 1,}) }
        }
        /// Multiply two rational numbers.
        pub fn mul(&self, other: &Rational)
         -> Result<Rational, OverflowError> {
            match (self.num.checked_mul(other.num),
                   (self.den as i32).checked_mul(other.den as i32)) {
                (Some(np), Some(dp)) => {
                    let gcd = gcd(np, dp);
                    Rational{num: np / gcd,
                             den: (dp / gcd) as u32,}.check_overflow()
                }
                _ => {
                    let n1d2 = gcd(self.num, other.den as i32);
                    let n2d1 = gcd(self.den as i32, other.num);
                    Rational{num:
                                 match (self.num /
                                            n1d2).checked_mul(other.num /
                                                                  n2d1).ok_or(OverflowError)
                                     {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 },
                             den:
                                 match ((self.den as i32) /
                                            n2d1).checked_mul((other.den as
                                                                   i32) /
                                                                  n1d2).ok_or(OverflowError)
                                     {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 } as u32,}.check_overflow()
                }
            }
        }
        /// Divide two rationals; a/b = a * (1/b)
        #[inline]
        pub fn div(&self, other: &Rational)
         -> Result<Rational, OverflowError> {
            self.mul(&match other.recip() {
                          ::std::result::Result::Ok(val) => val,
                          ::std::result::Result::Err(err) => {
                              return ::std::result::Result::Err(::std::convert::From::from(err))
                          }
                      })
        }
        /// Add two rationals
        pub fn add(&self, other: &Rational)
         -> Result<Rational, OverflowError> {
            let dgcd = gcd(self.den as i32, other.den as i32) as u32;
            let a = self.den / dgcd;
            let b = other.den / dgcd;
            let denom =
                match self.den.checked_mul(b).ok_or(OverflowError) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            Rational{num: self.num * (b as i32) + other.num * (a as i32),
                     den: denom,}.check_overflow()
        }
        /// Subtract two rationals; a - b = a + -b.
        #[inline]
        pub fn sub(&self, other: &Rational)
         -> Result<Rational, OverflowError> {
            self.add(&other.negate())
        }
    }
    impl Ord for Rational {
        /// Compare two rational numbers.
        fn cmp(&self, other: &Rational) -> cmp::Ordering {
            if self.is_negative() != other.is_negative() {
                return self.num.cmp(&other.num)
            }
            if self.is_negative() {
                return self.negate().cmp(&other.negate()).reverse()
            }
            match (self.num.checked_mul(other.den as i32),
                   (self.den as i32).checked_mul(other.num)) {
                (Some(a), Some(b)) => a.cmp(&b),
                _ => {
                    if self.den == other.den {
                        return self.num.cmp(&other.num)
                    }
                    if self.num == other.num {
                        return other.den.cmp(&self.den)
                    }
                    let (ai, af) =
                        (self.num / (self.den as i32),
                         self.num % (self.den as i32));
                    let (bi, bf) =
                        (other.num / (other.den as i32),
                         other.num % (other.den as i32));
                    if ai > bi {
                        cmp::Ordering::Greater
                    } else if ai < bi {
                        cmp::Ordering::Less
                    } else {
                        (Rational{num: other.den as i32,
                                  den:
                                      bf as
                                          u32,}).cmp(&Rational{num:
                                                                   self.den as
                                                                       i32,
                                                               den:
                                                                   af as
                                                                       u32,})
                    }
                }
            }
        }
    }
    impl PartialOrd for Rational {
        fn partial_cmp(&self, other: &Rational) -> Option<cmp::Ordering> {
            Some(self.cmp(other))
        }
    }
    /// Trait for things that can be converted to a float
    pub trait AsFloat {
        fn as_float(&self)
        -> f64;
    }
    impl AsFloat for f64 {
        fn as_float(&self) -> f64 { *self }
    }
    impl AsFloat for Rational {
        fn as_float(&self) -> f64 { (self.num as f64) / (self.den as f64) }
    }
}
pub mod value {
    //! Value module. Can be exact or inexact.
    #[prelude_import]
    use std::prelude::v1::*;
    use rational::*;
    use std::cmp;
    use std::cmp::Ord;
    use std::ops::{Add, Sub, Mul, Div, Neg};
    use std::fmt;
    /// Value type. A Value is either exact or inexact.
    /// All values are valid numbers and are not Infinity or NaN.
    pub enum Value {

        /// An inexact (floating-point) value
        Inexact(f64),

        /// An exact (rational) value
        Exact(Rational),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Value {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&Value::Inexact(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Inexact");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Value::Exact(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Exact");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Value {
        #[inline]
        fn clone(&self) -> Value {
            match (&*self,) {
                (&Value::Inexact(ref __self_0),) => {
                    ::std::clone::assert_receiver_is_clone(&(*__self_0));
                    *self
                }
                (&Value::Exact(ref __self_0),) => {
                    ::std::clone::assert_receiver_is_clone(&(*__self_0));
                    *self
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Value { }
    impl AsFloat for Value {
        #[inline]
        fn as_float(&self) -> f64 {
            match self {
                &Value::Inexact(a) => a,
                &Value::Exact(ref a) => a.as_float(),
            }
        }
    }
    impl PartialEq for Value {
        #[inline]
        fn eq(&self, other: &Value) -> bool {
            self.cmp(other) == cmp::Ordering::Equal
        }
        #[inline]
        fn ne(&self, other: &Value) -> bool {
            self.cmp(other) != cmp::Ordering::Equal
        }
    }
    impl Eq for Value { }
    impl Ord for Value {
        fn cmp(&self, other: &Value) -> cmp::Ordering {
            match (self, other) {
                (&Value::Inexact(ref a), &Value::Inexact(ref b)) =>
                a.partial_cmp(b).unwrap(),
                (&Value::Exact(ref a), &Value::Exact(ref b)) => a.cmp(b),
                (a, b) => a.as_float().partial_cmp(&b.as_float()).unwrap(),
            }
        }
    }
    impl PartialOrd for Value {
        fn partial_cmp(&self, other: &Value) -> Option<cmp::Ordering> {
            Some(self.cmp(other))
        }
    }
    /// An error caused by an arithmetic operator.
    #[structural_match]
    pub enum ArithmeticError {

        /// Caused by division by zero
        DivideByZeroError,

        /// Caused by an invalid argument
        DomainError,

        /// Caused by overflow
        OverflowError,

        /// Incompatible units or invalid use of units
        UnitError,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ArithmeticError {
        #[inline]
        fn clone(&self) -> ArithmeticError {
            match (&*self,) {
                (&ArithmeticError::DivideByZeroError,) => { *self }
                (&ArithmeticError::DomainError,) => { *self }
                (&ArithmeticError::OverflowError,) => { *self }
                (&ArithmeticError::UnitError,) => { *self }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ArithmeticError { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::hash::Hash for ArithmeticError {
        fn hash<__H: ::std::hash::Hasher>(&self, __arg_0: &mut __H) -> () {
            match (&*self,) {
                (&ArithmeticError::DivideByZeroError,) => {
                    ::std::hash::Hash::hash(&unsafe {
                                                 ::std::intrinsics::discriminant_value(self)
                                             }, __arg_0);
                }
                (&ArithmeticError::DomainError,) => {
                    ::std::hash::Hash::hash(&unsafe {
                                                 ::std::intrinsics::discriminant_value(self)
                                             }, __arg_0);
                }
                (&ArithmeticError::OverflowError,) => {
                    ::std::hash::Hash::hash(&unsafe {
                                                 ::std::intrinsics::discriminant_value(self)
                                             }, __arg_0);
                }
                (&ArithmeticError::UnitError,) => {
                    ::std::hash::Hash::hash(&unsafe {
                                                 ::std::intrinsics::discriminant_value(self)
                                             }, __arg_0);
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for ArithmeticError {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match (&*self,) {
                (&ArithmeticError::DivideByZeroError,) => { }
                (&ArithmeticError::DomainError,) => { }
                (&ArithmeticError::OverflowError,) => { }
                (&ArithmeticError::UnitError,) => { }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ArithmeticError {
        #[inline]
        fn eq(&self, __arg_0: &ArithmeticError) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&ArithmeticError::DivideByZeroError,
                         &ArithmeticError::DivideByZeroError) => true,
                        (&ArithmeticError::DomainError,
                         &ArithmeticError::DomainError) => true,
                        (&ArithmeticError::OverflowError,
                         &ArithmeticError::OverflowError) => true,
                        (&ArithmeticError::UnitError,
                         &ArithmeticError::UnitError) => true,
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ArithmeticError {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&ArithmeticError::DivideByZeroError,) => {
                    let mut builder =
                        __arg_0.debug_tuple("DivideByZeroError");
                    builder.finish()
                }
                (&ArithmeticError::DomainError,) => {
                    let mut builder = __arg_0.debug_tuple("DomainError");
                    builder.finish()
                }
                (&ArithmeticError::OverflowError,) => {
                    let mut builder = __arg_0.debug_tuple("OverflowError");
                    builder.finish()
                }
                (&ArithmeticError::UnitError,) => {
                    let mut builder = __arg_0.debug_tuple("UnitError");
                    builder.finish()
                }
            }
        }
    }
    impl Value {
        /// Used for user input; approximates values that could be represented exactly (denominator 8)
        pub fn from_input(f: f64) -> Result<Value, ArithmeticError> {
            if !f.is_nan() && !f.is_infinite() {
                if (f * 8.0).fract() != 0.0 {
                    Ok(Value::Inexact(f))
                } else {
                    let num = f * 8.0;
                    if num.abs() > (i32::max_value() as f64) {
                        Ok(Value::Inexact(f))
                    } else {
                        Rational::new(num as i32,
                                      8).or(Err(ArithmeticError::DomainError)).map(Value::Exact)
                    }
                }
            } else {
                if f.is_infinite() {
                    Err(ArithmeticError::OverflowError)
                } else { Err(ArithmeticError::DomainError) }
            }
        }
        /// Convert a float into a Value, directly using the Inexact form. (Still checks for error)
        #[inline]
        pub fn from_float(f: f64) -> Result<Value, ArithmeticError> {
            if !f.is_nan() && !f.is_infinite() {
                Ok(Value::Inexact(f))
            } else {
                if f.is_infinite() {
                    Err(ArithmeticError::OverflowError)
                } else { Err(ArithmeticError::DomainError) }
            }
        }
        /// Get as an exact value (returns None if inexact)
        #[inline]
        pub fn get_exact(&self) -> Option<&Rational> {
            match self {
                &Value::Exact(ref a) => Some(a),
                &Value::Inexact(_) => None,
            }
        }
        /// Converts self into an integer if possible.
        #[inline]
        pub fn as_integer(&self) -> Option<i32> {
            match self {
                &Value::Exact(ref a) =>
                if a.is_integer() { Some(a.num) } else { None },
                &Value::Inexact(a) =>
                if a.fract() == 0.0 && a.abs() <= (i32::max_value() as f64) {
                    Some(a as i32)
                } else { None },
            }
        }
        /// Zero value
        #[inline]
        pub fn zero() -> Value { Value::Exact(Rational::zero()) }
        /// Check if zero
        #[inline]
        pub fn is_zero(&self) -> bool {
            match self {
                &Value::Exact(ref a) => a.is_zero(),
                &Value::Inexact(a) => a == 0.0,
            }
        }
        pub fn add(&self, other: &Value) -> Result<Value, ArithmeticError> {
            match (self.get_exact(), other.get_exact()) {
                (Some(a), Some(b)) =>
                a.add(b).map(Value::Exact).or_else(|_|
                                                       Value::from_float(self.as_float()
                                                                             +
                                                                             other.as_float())),
                _ => Value::from_float(self.as_float() + other.as_float()),
            }
        }
        pub fn sub(&self, other: &Value) -> Result<Value, ArithmeticError> {
            match (self.get_exact(), other.get_exact()) {
                (Some(a), Some(b)) =>
                a.sub(b).map(Value::Exact).or_else(|_|
                                                       Value::from_float(self.as_float()
                                                                             -
                                                                             other.as_float())),
                _ => Value::from_float(self.as_float() - other.as_float()),
            }
        }
        pub fn mul(&self, other: &Value) -> Result<Value, ArithmeticError> {
            match (self.get_exact(), other.get_exact()) {
                (Some(a), Some(b)) =>
                a.mul(b).map(Value::Exact).or_else(|_|
                                                       Value::from_float(self.as_float()
                                                                             *
                                                                             other.as_float())),
                _ => Value::from_float(self.as_float() * other.as_float()),
            }
        }
        pub fn div(&self, other: &Value) -> Result<Value, ArithmeticError> {
            if other.as_float() == 0.0 {
                return Err(ArithmeticError::DivideByZeroError);
            }
            match (self.get_exact(), other.get_exact()) {
                (Some(a), Some(b)) =>
                a.div(b).map(Value::Exact).or_else(|_|
                                                       Value::from_float(self.as_float()
                                                                             /
                                                                             other.as_float())),
                _ => Value::from_float(self.as_float() / other.as_float()),
            }
        }
        pub fn pow(&self, other: &Value) -> Result<Value, ArithmeticError> {
            match self.get_exact() {
                Some(a) =>
                if let Some(e) = other.as_integer() {
                    a.pow(e).map(Value::Exact).or_else(|_|
                                                           Value::from_float(a.as_float().powi(e)))
                } else {
                    Value::from_float(a.as_float().powf(other.as_float()))
                },
                None =>
                Value::from_float(self.as_float().powf(other.as_float())),
            }
        }
    }
    impl Add for Value {
        type
        Output
        =
        Value;
        fn add(self, other: Value) -> Value { (&self).add(&other).unwrap() }
    }
    impl Sub for Value {
        type
        Output
        =
        Value;
        fn sub(self, other: Value) -> Value { (&self).sub(&other).unwrap() }
    }
    impl Mul for Value {
        type
        Output
        =
        Value;
        fn mul(self, other: Value) -> Value { (&self).mul(&other).unwrap() }
    }
    impl Div for Value {
        type
        Output
        =
        Value;
        fn div(self, other: Value) -> Value { (&self).div(&other).unwrap() }
    }
    impl Neg for Value {
        type
        Output
        =
        Value;
        fn neg(self) -> Value {
            match self {
                Value::Exact(a) => Value::Exact(-a),
                Value::Inexact(a) => Value::Inexact(-a),
            }
        }
    }
    /// Format as inexact or exact
    impl fmt::Display for Value {
        fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
            match self {
                &Value::Inexact(a) =>
                f.write_fmt(::std::fmt::Arguments::new_v1({
                                                              static __STATIC_FMTSTR:
                                                                     &'static [&'static str]
                                                                     =
                                                                  &[""];
                                                              __STATIC_FMTSTR
                                                          },
                                                          &match (&a,) {
                                                               (__arg0,) =>
                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                            ::std::fmt::Display::fmt)],
                                                           })),
                &Value::Exact(ref a) =>
                f.write_fmt(::std::fmt::Arguments::new_v1({
                                                              static __STATIC_FMTSTR:
                                                                     &'static [&'static str]
                                                                     =
                                                                  &[""];
                                                              __STATIC_FMTSTR
                                                          },
                                                          &match (&a,) {
                                                               (__arg0,) =>
                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                            ::std::fmt::Display::fmt)],
                                                           })),
            }
        }
    }
}
pub mod unit {
    //! Unit module. Contains a Unit struct that can be used to represent the dimensions of a unit.
    #[prelude_import]
    use std::prelude::v1::*;
    use rational::*;
    use std::ops::{Add, Sub, Mul, Neg};
    /// A unit struct, representing unit dimensions.
    #[structural_match]
    pub struct Unit {
        /// exponent of meters
        pub m: Rational,
        /// exponent of kilograms
        pub kg: Rational,
        /// exponent of seconds
        pub s: Rational,
        /// exponent of Amperes
        pub a: Rational,
        /// exponent of Kelvins
        pub k: Rational,
        /// exponent of candelas
        pub cd: Rational,
        /// exponent of moles
        pub mol: Rational,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Unit {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match *self {
                Unit {
                m: ref __self_0_0,
                kg: ref __self_0_1,
                s: ref __self_0_2,
                a: ref __self_0_3,
                k: ref __self_0_4,
                cd: ref __self_0_5,
                mol: ref __self_0_6 } => {
                    (*__self_0_0).assert_receiver_is_total_eq();
                    (*__self_0_1).assert_receiver_is_total_eq();
                    (*__self_0_2).assert_receiver_is_total_eq();
                    (*__self_0_3).assert_receiver_is_total_eq();
                    (*__self_0_4).assert_receiver_is_total_eq();
                    (*__self_0_5).assert_receiver_is_total_eq();
                    (*__self_0_6).assert_receiver_is_total_eq();
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Unit {
        #[inline]
        fn eq(&self, __arg_0: &Unit) -> bool {
            match *__arg_0 {
                Unit {
                m: ref __self_1_0,
                kg: ref __self_1_1,
                s: ref __self_1_2,
                a: ref __self_1_3,
                k: ref __self_1_4,
                cd: ref __self_1_5,
                mol: ref __self_1_6 } =>
                match *self {
                    Unit {
                    m: ref __self_0_0,
                    kg: ref __self_0_1,
                    s: ref __self_0_2,
                    a: ref __self_0_3,
                    k: ref __self_0_4,
                    cd: ref __self_0_5,
                    mol: ref __self_0_6 } =>
                    true && (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4) &&
                        (*__self_0_5) == (*__self_1_5) &&
                        (*__self_0_6) == (*__self_1_6),
                },
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &Unit) -> bool {
            match *__arg_0 {
                Unit {
                m: ref __self_1_0,
                kg: ref __self_1_1,
                s: ref __self_1_2,
                a: ref __self_1_3,
                k: ref __self_1_4,
                cd: ref __self_1_5,
                mol: ref __self_1_6 } =>
                match *self {
                    Unit {
                    m: ref __self_0_0,
                    kg: ref __self_0_1,
                    s: ref __self_0_2,
                    a: ref __self_0_3,
                    k: ref __self_0_4,
                    cd: ref __self_0_5,
                    mol: ref __self_0_6 } =>
                    false || (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4) ||
                        (*__self_0_5) != (*__self_1_5) ||
                        (*__self_0_6) != (*__self_1_6),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Unit {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                Unit {
                m: ref __self_0_0,
                kg: ref __self_0_1,
                s: ref __self_0_2,
                a: ref __self_0_3,
                k: ref __self_0_4,
                cd: ref __self_0_5,
                mol: ref __self_0_6 } => {
                    let mut builder = __arg_0.debug_struct("Unit");
                    let _ = builder.field("m", &&(*__self_0_0));
                    let _ = builder.field("kg", &&(*__self_0_1));
                    let _ = builder.field("s", &&(*__self_0_2));
                    let _ = builder.field("a", &&(*__self_0_3));
                    let _ = builder.field("k", &&(*__self_0_4));
                    let _ = builder.field("cd", &&(*__self_0_5));
                    let _ = builder.field("mol", &&(*__self_0_6));
                    builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Unit {
        #[inline]
        fn clone(&self) -> Unit {
            match *self {
                Unit {
                m: ref __self_0_0,
                kg: ref __self_0_1,
                s: ref __self_0_2,
                a: ref __self_0_3,
                k: ref __self_0_4,
                cd: ref __self_0_5,
                mol: ref __self_0_6 } => {
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_0));
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_1));
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_2));
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_3));
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_4));
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_5));
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_6));
                    *self
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Unit { }
    impl Unit {
        /// zero unit (unitless)
        pub fn zero() -> Unit {
            Unit{m: Rational::zero(),
                 kg: Rational::zero(),
                 s: Rational::zero(),
                 a: Rational::zero(),
                 k: Rational::zero(),
                 cd: Rational::zero(),
                 mol: Rational::zero(),}
        }
        /// add two units (corresponds to multiplication of values)
        pub fn add(&self, other: &Unit) -> Result<Unit, OverflowError> {
            Ok(Unit{m:
                        match self.m.add(&other.m) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    kg:
                        match self.kg.add(&other.kg) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    s:
                        match self.s.add(&other.s) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    a:
                        match self.a.add(&other.a) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    k:
                        match self.k.add(&other.k) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    cd:
                        match self.cd.add(&other.cd) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    mol:
                        match self.mol.add(&other.mol) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },})
        }
        /// subtract two units (corresponds to division of values)
        pub fn sub(&self, other: &Unit) -> Result<Unit, OverflowError> {
            Ok(Unit{m:
                        match self.m.sub(&other.m) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    kg:
                        match self.kg.sub(&other.kg) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    s:
                        match self.s.sub(&other.s) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    a:
                        match self.a.sub(&other.a) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    k:
                        match self.k.sub(&other.k) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    cd:
                        match self.cd.sub(&other.cd) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    mol:
                        match self.mol.sub(&other.mol) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },})
        }
        /// multiply a unit by a scalar (corresponds to exponentiation)
        pub fn mul(&self, other: &Rational) -> Result<Unit, OverflowError> {
            Ok(Unit{m:
                        match self.m.mul(&other) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    kg:
                        match self.kg.mul(&other) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    s:
                        match self.s.mul(&other) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    a:
                        match self.a.mul(&other) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    k:
                        match self.k.mul(&other) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    cd:
                        match self.cd.mul(&other) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },
                    mol:
                        match self.mol.mul(&other) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },})
        }
    }
    impl Add for Unit {
        type
        Output
        =
        Unit;
        fn add(self, other: Unit) -> Unit {
            (&self).add(&other).expect("unit overflow")
        }
    }
    impl Sub for Unit {
        type
        Output
        =
        Unit;
        fn sub(self, other: Unit) -> Unit {
            (&self).sub(&other).expect("unit overflow")
        }
    }
    impl Mul<Rational> for Unit {
        type
        Output
        =
        Unit;
        fn mul(self, other: Rational) -> Unit {
            (&self).mul(&other).expect("unit overflow")
        }
    }
    /// Negation (reciprocal)
    impl Neg for Unit {
        type
        Output
        =
        Unit;
        fn neg(self) -> Unit {
            Unit{m: -self.m,
                 kg: -self.kg,
                 s: -self.s,
                 a: -self.a,
                 k: -self.k,
                 cd: -self.cd,
                 mol: -self.mol,}
        }
    }
}
pub mod uval {
    //! Value with units. Ties together unit and value.
    #[prelude_import]
    use std::prelude::v1::*;
    use unit::*;
    use value::*;
    use rational::{OverflowError, AsFloat};
    use std::cmp;
    use std::ops::{Add, Sub, Mul, Div, Neg};
    use std::fmt;
    /// A value with units
    #[structural_match]
    pub struct UnitValue {
        /// Numerical value
        pub value: Value,
        /// Unit
        pub unit: Unit,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for UnitValue {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match *self {
                UnitValue { value: ref __self_0_0, unit: ref __self_0_1 } => {
                    (*__self_0_0).assert_receiver_is_total_eq();
                    (*__self_0_1).assert_receiver_is_total_eq();
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for UnitValue {
        #[inline]
        fn eq(&self, __arg_0: &UnitValue) -> bool {
            match *__arg_0 {
                UnitValue { value: ref __self_1_0, unit: ref __self_1_1 } =>
                match *self {
                    UnitValue { value: ref __self_0_0, unit: ref __self_0_1 }
                    =>
                    true && (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &UnitValue) -> bool {
            match *__arg_0 {
                UnitValue { value: ref __self_1_0, unit: ref __self_1_1 } =>
                match *self {
                    UnitValue { value: ref __self_0_0, unit: ref __self_0_1 }
                    =>
                    false || (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for UnitValue {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                UnitValue { value: ref __self_0_0, unit: ref __self_0_1 } => {
                    let mut builder = __arg_0.debug_struct("UnitValue");
                    let _ = builder.field("value", &&(*__self_0_0));
                    let _ = builder.field("unit", &&(*__self_0_1));
                    builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for UnitValue {
        #[inline]
        fn clone(&self) -> UnitValue {
            match *self {
                UnitValue { value: ref __self_0_0, unit: ref __self_0_1 } => {
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_0));
                    ::std::clone::assert_receiver_is_clone(&(*__self_0_1));
                    *self
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for UnitValue { }
    impl From<OverflowError> for ArithmeticError {
        /// Convert an OverflowError (from Rational) to a value's ArithmeticError
        fn from(_: OverflowError) -> ArithmeticError {
            ArithmeticError::OverflowError
        }
    }
    /// UnitValues can be compared only if units correspond
    impl PartialOrd for UnitValue {
        #[inline]
        fn partial_cmp(&self, other: &UnitValue) -> Option<cmp::Ordering> {
            if self.unit == other.unit {
                self.value.partial_cmp(&other.value)
            } else { None }
        }
    }
    impl AsFloat for UnitValue {
        /// Convert into a float (only valid for unitless quantities)
        #[inline]
        fn as_float(&self) -> f64 {
            if !self.unitless() {
                ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["treating as unitless\n"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match () {
                                                                     () => [],
                                                                 }));
            }
            self.value.as_float()
        }
    }
    impl UnitValue {
        #[inline]
        pub fn from_input(f: f64) -> Result<UnitValue, ArithmeticError> {
            Ok(UnitValue{value:
                             match Value::from_input(f) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },
                         unit: Unit::zero(),})
        }
        #[inline]
        pub fn from_float(f: f64) -> Result<UnitValue, ArithmeticError> {
            Ok(UnitValue{value:
                             match Value::from_float(f) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },
                         unit: Unit::zero(),})
        }
        #[inline]
        pub fn zero() -> UnitValue {
            UnitValue{value: Value::zero(), unit: Unit::zero(),}
        }
        #[inline]
        pub fn is_zero(&self) -> bool { self.value.is_zero() }
        /// zero values are always unitless; check for that
        #[inline]
        fn checked_uval(value: Value, unit: Unit) -> UnitValue {
            if value.is_zero() {
                UnitValue::zero()
            } else { UnitValue{value: value, unit: unit,} }
        }
        /// is this value unitless
        #[inline]
        pub fn unitless(&self) -> bool { self.unit == Unit::zero() }
        pub fn add(&self, other: &UnitValue)
         -> Result<UnitValue, ArithmeticError> {
            if self.unit == other.unit {
                Ok(UnitValue::checked_uval(match (&self.value).add(&other.value)
                                               {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           }, self.unit))
            } else {
                if self.is_zero() { return Ok(other.clone()) }
                if other.is_zero() { return Ok(self.clone()) }
                Err(ArithmeticError::UnitError)
            }
        }
        pub fn sub(&self, other: &UnitValue)
         -> Result<UnitValue, ArithmeticError> {
            if self.unit == other.unit {
                Ok(UnitValue::checked_uval(match (&self.value).sub(&other.value)
                                               {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           }, self.unit))
            } else {
                if self.is_zero() { return Ok(other.clone()) }
                if other.is_zero() { return Ok(self.clone()) }
                Err(ArithmeticError::UnitError)
            }
        }
        pub fn mul(&self, other: &UnitValue)
         -> Result<UnitValue, ArithmeticError> {
            Ok(UnitValue{value:
                             match (&self.value).mul(&other.value) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },
                         unit:
                             match (&self.unit).add(&other.unit) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },})
        }
        pub fn div(&self, other: &UnitValue)
         -> Result<UnitValue, ArithmeticError> {
            Ok(UnitValue{value:
                             match (&self.value).div(&other.value) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },
                         unit:
                             match (&self.unit).sub(&other.unit) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },})
        }
        pub fn pow(&self, other: &UnitValue)
         -> Result<UnitValue, ArithmeticError> {
            if other.unitless() {
                if self.unitless() {
                    Ok(UnitValue{value:
                                     match (&self.value).pow(&other.value) {
                                         ::std::result::Result::Ok(val) =>
                                         val,
                                         ::std::result::Result::Err(err) => {
                                             return ::std::result::Result::Err(::std::convert::From::from(err))
                                         }
                                     },
                                 unit: Unit::zero(),})
                } else {
                    match other.value.get_exact() {
                        Some(e) =>
                        Ok(UnitValue{value:
                                         match (&self.value).pow(&other.value)
                                             {
                                             ::std::result::Result::Ok(val) =>
                                             val,
                                             ::std::result::Result::Err(err)
                                             => {
                                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                                             }
                                         },
                                     unit:
                                         match (&self.unit).mul(e) {
                                             ::std::result::Result::Ok(val) =>
                                             val,
                                             ::std::result::Result::Err(err)
                                             => {
                                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                                             }
                                         },}),
                        None => Err(ArithmeticError::UnitError),
                    }
                }
            } else { Err(ArithmeticError::UnitError) }
        }
    }
    impl Add for UnitValue {
        type
        Output
        =
        UnitValue;
        fn add(self, other: UnitValue) -> UnitValue {
            (&self).add(&other).unwrap()
        }
    }
    impl Sub for UnitValue {
        type
        Output
        =
        UnitValue;
        fn sub(self, other: UnitValue) -> UnitValue {
            (&self).sub(&other).unwrap()
        }
    }
    impl Mul for UnitValue {
        type
        Output
        =
        UnitValue;
        fn mul(self, other: UnitValue) -> UnitValue {
            (&self).mul(&other).unwrap()
        }
    }
    impl Div for UnitValue {
        type
        Output
        =
        UnitValue;
        fn div(self, other: UnitValue) -> UnitValue {
            (&self).div(&other).unwrap()
        }
    }
    impl Neg for UnitValue {
        type
        Output
        =
        UnitValue;
        fn neg(self) -> UnitValue {
            UnitValue{value: -self.value, unit: self.unit,}
        }
    }
    impl fmt::Display for UnitValue {
        /// Display value followed by unit (unless unitless)
        fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
            if self.unitless() {
                f.write_fmt(::std::fmt::Arguments::new_v1({
                                                              static __STATIC_FMTSTR:
                                                                     &'static [&'static str]
                                                                     =
                                                                  &[""];
                                                              __STATIC_FMTSTR
                                                          },
                                                          &match (&self.value,)
                                                               {
                                                               (__arg0,) =>
                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                            ::std::fmt::Display::fmt)],
                                                           }))
            } else {
                f.write_fmt(::std::fmt::Arguments::new_v1({
                                                              static __STATIC_FMTSTR:
                                                                     &'static [&'static str]
                                                                     =
                                                                  &["", " "];
                                                              __STATIC_FMTSTR
                                                          },
                                                          &match (&self.value,
                                                                  &self.unit)
                                                               {
                                                               (__arg0,
                                                                __arg1) =>
                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                            ::std::fmt::Display::fmt),
                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                            ::std::fmt::Display::fmt)],
                                                           }))
            }
        }
    }
}
pub mod units {
    //! List of units and constants
    #[prelude_import]
    use std::prelude::v1::*;
    use unit::Unit;
    use uval::UnitValue;
    use value::Value;
    use rational::Rational;
    use std::fmt;
    use std::fmt::Write;
    use phf;
    const DIMENSIONLESS: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const LENGTH: Unit =
        Unit{m: Rational{num: 1, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const MASS: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const TIME: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 1, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const CURRENT: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 1, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const TEMPERATURE: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 1, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const INTENSITY: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 1, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const AMOUNT: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 1, den: 1,},};
    const FREQUENCY: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: -1, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const FORCE: Unit =
        Unit{m: Rational{num: 1, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const PRESSURE: Unit =
        Unit{m: Rational{num: -1, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const ENERGY: Unit =
        Unit{m: Rational{num: 2, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const POWER: Unit =
        Unit{m: Rational{num: 2, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -3, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const CHARGE: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 1, den: 1,},
             a: Rational{num: 1, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const VOLTAGE: Unit =
        Unit{m: Rational{num: 2, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -3, den: 1,},
             a: Rational{num: -1, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const CAPACITANCE: Unit =
        Unit{m: Rational{num: -2, den: 1,},
             kg: Rational{num: -1, den: 1,},
             s: Rational{num: 4, den: 1,},
             a: Rational{num: 2, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const RESISTANCE: Unit =
        Unit{m: Rational{num: 2, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -3, den: 1,},
             a: Rational{num: -2, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const MAG_FIELD: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: -1, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const AREA: Unit =
        Unit{m: Rational{num: 2, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const VOLUME: Unit =
        Unit{m: Rational{num: 3, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const C_UNITS: Unit =
        Unit{m: Rational{num: 1, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: -1, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const GC_UNITS: Unit =
        Unit{m: Rational{num: 3, den: 1,},
             kg: Rational{num: -1, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const H_UNITS: Unit =
        Unit{m: Rational{num: 2, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -1, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const MU0_UNITS: Unit =
        Unit{m: Rational{num: 1, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: -2, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const EP0_UNITS: Unit =
        Unit{m: Rational{num: -3, den: 1,},
             kg: Rational{num: -1, den: 1,},
             s: Rational{num: 4, den: 1,},
             a: Rational{num: 2, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const KE_UNITS: Unit =
        Unit{m: Rational{num: 3, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -4, den: 1,},
             a: Rational{num: -2, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const NA_UNITS: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 0, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: -1, den: 1,},};
    const KB_UNITS: Unit =
        Unit{m: Rational{num: 2, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: -1, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const F_UNITS: Unit =
        Unit{m: Rational{num: 0, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: 1, den: 1,},
             a: Rational{num: 1, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: -1, den: 1,},};
    const R_UNITS: Unit =
        Unit{m: Rational{num: 2, den: 1,},
             kg: Rational{num: 1, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: -1, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: -1, den: 1,},};
    const G_UNITS: Unit =
        Unit{m: Rational{num: 1, den: 1,},
             kg: Rational{num: 0, den: 1,},
             s: Rational{num: -2, den: 1,},
             a: Rational{num: 0, den: 1,},
             k: Rational{num: 0, den: 1,},
             cd: Rational{num: 0, den: 1,},
             mol: Rational{num: 0, den: 1,},};
    const ONE: Value = Value::Exact(Rational{num: 1, den: 1,});
    /// Lookup table for named units
    static UNITS: phf::Map<&'static str, UnitValue> =
        ::phf::Map{key: 1897749892740154578u64,
                   disps:
                       ::phf::Slice::Static(&[(1u32, 63u32), (4u32, 22u32),
                                              (0u32, 0u32), (0u32, 0u32),
                                              (66u32, 56u32), (0u32, 0u32),
                                              (1u32, 31u32), (17u32, 23u32),
                                              (0u32, 7u32), (2u32, 69u32),
                                              (2u32, 1u32), (6u32, 15u32),
                                              (18u32, 12u32), (0u32, 65u32),
                                              (2u32, 0u32)]),
                   entries:
                       ::phf::Slice::Static(&[("deg",
                                               UnitValue{unit: DIMENSIONLESS,
                                                         value:
                                                             Value::Inexact(0.0174532925199432957),}),
                                              ("acre",
                                               UnitValue{unit: AREA,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       13641953,
                                                                                   den:
                                                                                       3371,}),}),
                                              ("F",
                                               UnitValue{unit: CAPACITANCE,
                                                         value: ONE,}),
                                              ("cal",
                                               UnitValue{unit: ENERGY,
                                                         value:
                                                             Value::Inexact(4.184),}),
                                              ("m",
                                               UnitValue{unit: LENGTH,
                                                         value: ONE,}),
                                              ("J",
                                               UnitValue{unit: ENERGY,
                                                         value: ONE,}),
                                              ("T",
                                               UnitValue{unit: MAG_FIELD,
                                                         value: ONE,}),
                                              ("atm",
                                               UnitValue{unit: PRESSURE,
                                                         value:
                                                             Value::Inexact(101325.0),}),
                                              ("mi",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       201168,
                                                                                   den:
                                                                                       125,}),}),
                                              ("Hz",
                                               UnitValue{unit: FREQUENCY,
                                                         value: ONE,}),
                                              ("s",
                                               UnitValue{unit: TIME,
                                                         value: ONE,}),
                                              ("_e",
                                               UnitValue{unit: CHARGE,
                                                         value:
                                                             Value::Inexact(1.60217656535e-19),}),
                                              ("km",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1000,
                                                                                   den:
                                                                                       1,}),}),
                                              ("sr",
                                               UnitValue{unit: DIMENSIONLESS,
                                                         value: ONE,}),
                                              ("_me",
                                               UnitValue{unit: MASS,
                                                         value:
                                                             Value::Inexact(9.1093829140e-31),}),
                                              ("lea",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       25146,
                                                                                   den:
                                                                                       125,}),}),
                                              ("tbsp",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Inexact(0.00001478676478125),}),
                                              ("day",
                                               UnitValue{unit: TIME,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       86400,
                                                                                   den:
                                                                                       1,}),}),
                                              ("hr",
                                               UnitValue{unit: TIME,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       3600,
                                                                                   den:
                                                                                       1,}),}),
                                              ("cup",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Inexact(0.0002365882365),}),
                                              ("gal",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Inexact(0.003785411784),}),
                                              ("_kB",
                                               UnitValue{unit: KB_UNITS,
                                                         value:
                                                             Value::Inexact(1.380648813e-23),}),
                                              ("L",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1,
                                                                                   den:
                                                                                       1000,}),}),
                                              ("kg",
                                               UnitValue{unit: MASS,
                                                         value: ONE,}),
                                              ("_ep0",
                                               UnitValue{unit: EP0_UNITS,
                                                         value:
                                                             Value::Inexact(8.854187817e-12),}),
                                              ("A",
                                               UnitValue{unit: CURRENT,
                                                         value: ONE,}),
                                              ("btu",
                                               UnitValue{unit: ENERGY,
                                                         value:
                                                             Value::Inexact(1055.056),}),
                                              ("tsp",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Inexact(0.00000492892159375),}),
                                              ("Pa",
                                               UnitValue{unit: PRESSURE,
                                                         value: ONE,}),
                                              ("_F",
                                               UnitValue{unit: F_UNITS,
                                                         value:
                                                             Value::Inexact(96485.336521),}),
                                              ("hp",
                                               UnitValue{unit: ENERGY,
                                                         value:
                                                             Value::Inexact(745.7),}),
                                              ("ohm",
                                               UnitValue{unit: RESISTANCE,
                                                         value: ONE,}),
                                              ("_h",
                                               UnitValue{unit: H_UNITS,
                                                         value:
                                                             Value::Inexact(6.62607004081e-34),}),
                                              ("fur",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       25146,
                                                                                   den:
                                                                                       125,}),}),
                                              ("mm",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1,
                                                                                   den:
                                                                                       1000,}),}),
                                              ("_ke",
                                               UnitValue{unit: KE_UNITS,
                                                         value:
                                                             Value::Inexact(8.987551787e9),}),
                                              ("C",
                                               UnitValue{unit: CHARGE,
                                                         value: ONE,}),
                                              ("N",
                                               UnitValue{unit: FORCE,
                                                         value: ONE,}),
                                              ("min",
                                               UnitValue{unit: TIME,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       60,
                                                                                   den:
                                                                                       1,}),}),
                                              ("yd",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1143,
                                                                                   den:
                                                                                       1250,}),}),
                                              ("mt",
                                               UnitValue{unit: MASS,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1000,
                                                                                   den:
                                                                                       1,}),}),
                                              ("Cal",
                                               UnitValue{unit: ENERGY,
                                                         value:
                                                             Value::Inexact(4184.0),}),
                                              ("ton",
                                               UnitValue{unit: MASS,
                                                         value:
                                                             Value::Inexact(907.18474),}),
                                              ("bar",
                                               UnitValue{unit: PRESSURE,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       100000,
                                                                                   den:
                                                                                       1,}),}),
                                              ("mL",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1,
                                                                                   den:
                                                                                       1000000,}),}),
                                              ("amu",
                                               UnitValue{unit: MASS,
                                                         value:
                                                             Value::Inexact(1.66053892173e-27),}),
                                              ("floz",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Inexact(0.0000295735295625),}),
                                              ("K",
                                               UnitValue{unit: TEMPERATURE,
                                                         value: ONE,}),
                                              ("oz",
                                               UnitValue{unit: MASS,
                                                         value:
                                                             Value::Inexact(0.02834952312),}),
                                              ("qt",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Inexact(0.000946352946),}),
                                              ("pt",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Inexact(0.000473176473),}),
                                              ("ac",
                                               UnitValue{unit: AREA,
                                                         value:
                                                             Value::Inexact(4046.8564224),}),
                                              ("_mu0",
                                               UnitValue{unit: MU0_UNITS,
                                                         value:
                                                             Value::Inexact(1.256637061e-6),}),
                                              ("_G",
                                               UnitValue{unit: GC_UNITS,
                                                         value:
                                                             Value::Inexact(6.6740831e-11),}),
                                              ("cm",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1,
                                                                                   den:
                                                                                       100,}),}),
                                              ("lb",
                                               UnitValue{unit: MASS,
                                                         value:
                                                             Value::Inexact(0.45359237),}),
                                              ("_mp",
                                               UnitValue{unit: MASS,
                                                         value:
                                                             Value::Inexact(1.67262177774e-27),}),
                                              ("V",
                                               UnitValue{unit: VOLTAGE,
                                                         value: ONE,}),
                                              ("_NA",
                                               UnitValue{unit: NA_UNITS,
                                                         value:
                                                             Value::Inexact(6.0221412927e23),}),
                                              ("ha",
                                               UnitValue{unit: AREA,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       10000,
                                                                                   den:
                                                                                       1,}),}),
                                              ("_c",
                                               UnitValue{unit: C_UNITS,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       299792458,
                                                                                   den:
                                                                                       1,}),}),
                                              ("W",
                                               UnitValue{unit: POWER,
                                                         value: ONE,}),
                                              ("nm",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1852,
                                                                                   den:
                                                                                       1,}),}),
                                              ("_R",
                                               UnitValue{unit: R_UNITS,
                                                         value:
                                                             Value::Inexact(8.314462175),}),
                                              ("_g",
                                               UnitValue{unit: G_UNITS,
                                                         value:
                                                             Value::Inexact(9.807),}),
                                              ("ft",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       381,
                                                                                   den:
                                                                                       1250,}),}),
                                              ("in",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       127,
                                                                                   den:
                                                                                       5000,}),}),
                                              ("tonne",
                                               UnitValue{unit: MASS,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1000,
                                                                                   den:
                                                                                       1,}),}),
                                              ("cd",
                                               UnitValue{unit: INTENSITY,
                                                         value: ONE,}),
                                              ("mol",
                                               UnitValue{unit: AMOUNT,
                                                         value: ONE,}),
                                              ("rad",
                                               UnitValue{unit: DIMENSIONLESS,
                                                         value: ONE,}),
                                              ("rd",
                                               UnitValue{unit: LENGTH,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       12573,
                                                                                   den:
                                                                                       2500,}),}),
                                              ("ml",
                                               UnitValue{unit: VOLUME,
                                                         value:
                                                             Value::Exact(Rational{num:
                                                                                       1,
                                                                                   den:
                                                                                       1000000,}),})]),};
    static LOOKUP: phf::Map<u32, &'static str> =
        ::phf::Map{key: 9603444721912725599u64,
                   disps: ::phf::Slice::Static(&[(4u32, 0u32), (6u32, 3u32)]),
                   entries:
                       ::phf::Slice::Static(&[(35389440u32, "J"),
                                              (655360u32, "Hz"),
                                              (1810432u32, "T"),
                                              (195305472u32, "F"),
                                              (169541632u32, "Pa"),
                                              (35430400u32, "V"),
                                              (35323904u32, "J"),
                                              (69632u32, "C"),
                                              (35434496u32, "ohm"),
                                              (18546688u32, "N")]),};
    /// Look up a name to find the corresponding unit
    pub fn get(key: &str) -> Option<UnitValue> { UNITS.get(key).cloned() }
    /// turn an exponent into the hex scheme above
    fn as_int(r: &Rational) -> Result<u8, ()> {
        if !r.is_integer() { return Err(()); }
        match r.num {
            a@0 ...9 => Ok(a as u8),
            a@-6 ...-1 => Ok((9 - a) as u8),
            _ => Err(()),
        }
    }
    /// generate a hash as described above
    fn u_hash(u: &Unit) -> Result<u32, ()> {
        Ok((match as_int(&u.m) {
                ::std::result::Result::Ok(val) => val,
                ::std::result::Result::Err(err) => {
                    return ::std::result::Result::Err(::std::convert::From::from(err))
                }
            } as u32) << 24 |
               (match as_int(&u.kg) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                } as u32) << 20 |
               (match as_int(&u.s) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                } as u32) << 16 |
               (match as_int(&u.a) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                } as u32) << 12 |
               (match as_int(&u.k) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                } as u32) << 8 |
               (match as_int(&u.cd) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                } as u32) << 4 |
               (match as_int(&u.mol) {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                } as u32) << 0 | 0)
    }
    impl fmt::Display for Unit {
        /// Display a unit as a string (separates numerator and denominator)
        fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
            match u_hash(self).ok().and_then(|a| LOOKUP.get(&a)) {
                Some(a) =>
                f.write_fmt(::std::fmt::Arguments::new_v1({
                                                              static __STATIC_FMTSTR:
                                                                     &'static [&'static str]
                                                                     =
                                                                  &[""];
                                                              __STATIC_FMTSTR
                                                          },
                                                          &match (&a,) {
                                                               (__arg0,) =>
                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                            ::std::fmt::Display::fmt)],
                                                           })),
                None => {
                    let mut num = String::new();
                    let mut den = String::new();
                    if !self.kg.is_negative() {
                        if self.kg.is_one() {
                            num.push_str("kg");
                            num.push(' ');
                        } else if !self.kg.is_zero() {
                            num.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"kg",
                                                                                &self.kg)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    } else {
                        let neg = -self.kg;
                        if neg.is_one() {
                            den.push_str("kg");
                            den.push(' ');
                        } else if !neg.is_zero() {
                            den.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"kg",
                                                                                &neg)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    };
                    if !self.m.is_negative() {
                        if self.m.is_one() {
                            num.push_str("m");
                            num.push(' ');
                        } else if !self.m.is_zero() {
                            num.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"m",
                                                                                &self.m)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    } else {
                        let neg = -self.m;
                        if neg.is_one() {
                            den.push_str("m");
                            den.push(' ');
                        } else if !neg.is_zero() {
                            den.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"m",
                                                                                &neg)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    };
                    if !self.s.is_negative() {
                        if self.s.is_one() {
                            num.push_str("s");
                            num.push(' ');
                        } else if !self.s.is_zero() {
                            num.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"s",
                                                                                &self.s)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    } else {
                        let neg = -self.s;
                        if neg.is_one() {
                            den.push_str("s");
                            den.push(' ');
                        } else if !neg.is_zero() {
                            den.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"s",
                                                                                &neg)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    };
                    if !self.a.is_negative() {
                        if self.a.is_one() {
                            num.push_str("A");
                            num.push(' ');
                        } else if !self.a.is_zero() {
                            num.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"A",
                                                                                &self.a)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    } else {
                        let neg = -self.a;
                        if neg.is_one() {
                            den.push_str("A");
                            den.push(' ');
                        } else if !neg.is_zero() {
                            den.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"A",
                                                                                &neg)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    };
                    if !self.mol.is_negative() {
                        if self.mol.is_one() {
                            num.push_str("mol");
                            num.push(' ');
                        } else if !self.mol.is_zero() {
                            num.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"mol",
                                                                                &self.mol)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    } else {
                        let neg = -self.mol;
                        if neg.is_one() {
                            den.push_str("mol");
                            den.push(' ');
                        } else if !neg.is_zero() {
                            den.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"mol",
                                                                                &neg)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    };
                    if !self.k.is_negative() {
                        if self.k.is_one() {
                            num.push_str("K");
                            num.push(' ');
                        } else if !self.k.is_zero() {
                            num.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"K",
                                                                                &self.k)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    } else {
                        let neg = -self.k;
                        if neg.is_one() {
                            den.push_str("K");
                            den.push(' ');
                        } else if !neg.is_zero() {
                            den.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"K",
                                                                                &neg)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    };
                    if !self.cd.is_negative() {
                        if self.cd.is_one() {
                            num.push_str("cd");
                            num.push(' ');
                        } else if !self.cd.is_zero() {
                            num.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"cd",
                                                                                &self.cd)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    } else {
                        let neg = -self.cd;
                        if neg.is_one() {
                            den.push_str("cd");
                            den.push(' ');
                        } else if !neg.is_zero() {
                            den.write_fmt(::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["",
                                                                                  "^",
                                                                                  " "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&"cd",
                                                                                &neg)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         })).unwrap();
                        }
                    };
                    match (num.is_empty(), den.is_empty()) {
                        (true, true) =>
                        f.write_fmt(::std::fmt::Arguments::new_v1({
                                                                      static __STATIC_FMTSTR:
                                                                             &'static [&'static str]
                                                                             =
                                                                          &[];
                                                                      __STATIC_FMTSTR
                                                                  },
                                                                  &match () {
                                                                       () =>
                                                                       [],
                                                                   })),
                        (true, false) =>
                        f.write_fmt(::std::fmt::Arguments::new_v1({
                                                                      static __STATIC_FMTSTR:
                                                                             &'static [&'static str]
                                                                             =
                                                                          &["/ "];
                                                                      __STATIC_FMTSTR
                                                                  },
                                                                  &match (&den.trim_right(),)
                                                                       {
                                                                       (__arg0,)
                                                                       =>
                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                    ::std::fmt::Display::fmt)],
                                                                   })),
                        (false, true) =>
                        f.write_fmt(::std::fmt::Arguments::new_v1({
                                                                      static __STATIC_FMTSTR:
                                                                             &'static [&'static str]
                                                                             =
                                                                          &[""];
                                                                      __STATIC_FMTSTR
                                                                  },
                                                                  &match (&num.trim_right(),)
                                                                       {
                                                                       (__arg0,)
                                                                       =>
                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                    ::std::fmt::Display::fmt)],
                                                                   })),
                        (false, false) =>
                        f.write_fmt(::std::fmt::Arguments::new_v1({
                                                                      static __STATIC_FMTSTR:
                                                                             &'static [&'static str]
                                                                             =
                                                                          &["",
                                                                            "/ "];
                                                                      __STATIC_FMTSTR
                                                                  },
                                                                  &match (&num,
                                                                          &den.trim_right())
                                                                       {
                                                                       (__arg0,
                                                                        __arg1)
                                                                       =>
                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                    ::std::fmt::Display::fmt),
                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                    ::std::fmt::Display::fmt)],
                                                                   })),
                    }
                }
            }
        }
    }
}
use rational::AsFloat;
/// A mathematical expression. Can be either known or unknown (at present, all expressions are known.)
pub enum Expression {

    /// A known value (with unit).
    Value(uval::UnitValue),

    /// An error has occurred; errors propagate to all expressions in which it is involved.
    Error(value::ArithmeticError),

    /// Exponentiation, a^b
    Exp(Box<Expression>, Box<Expression>),

    /// Multiplication, a*b
    Mul(Box<Expression>, Box<Expression>),

    /// Division, a/b
    Div(Box<Expression>, Box<Expression>),

    /// Addition, a+b
    Add(Box<Expression>, Box<Expression>),

    /// Subtraction, a-b
    Sub(Box<Expression>, Box<Expression>),

    /// Negation, -a
    Neg(Box<Expression>),

    /// Function call, f(a,b,c...)
    Call(Box<Fn(Vec<f64>) -> f64>, Vec<Expression>),
}
/// Types that can be converted to a value implement this trait.
pub trait ToValue {
    /// Convert this object to a value or return an error.
    fn to_value(&self)
    -> Result<uval::UnitValue, value::ArithmeticError>;
}
/// Make a Value Expression from a ToValue type
#[inline]
pub fn make_value<V: ToValue>(v: V) -> Expression {
    v.to_value().map(Expression::Value).unwrap_or_else(Expression::Error)
}
/// This is only called when handling user input. It treats some
/// numbers that can be handled exactly as fractions rather than
/// floating-point inexact numbers.
#[inline]
pub fn input_value(v: f64) -> Expression {
    make_value(uval::UnitValue::from_input(v))
}
impl ToValue for Result<uval::UnitValue, value::ArithmeticError> {
    #[inline]
    fn to_value(&self) -> Result<uval::UnitValue, value::ArithmeticError> {
        *self
    }
}
impl ToValue for uval::UnitValue {
    #[inline]
    fn to_value(&self) -> Result<uval::UnitValue, value::ArithmeticError> {
        Ok(*self)
    }
}
impl ToValue for f64 {
    #[inline]
    fn to_value(&self) -> Result<uval::UnitValue, value::ArithmeticError> {
        uval::UnitValue::from_float(*self)
    }
}
/// Expressions can be compared for equality
impl PartialEq for Expression {
    fn eq(&self, other: &Expression) -> bool {
        match (self, other) {
            (&Expression::Value(ref a), &Expression::Value(ref b)) => a == b,
            (&Expression::Exp(ref a, ref b), &Expression::Exp(ref c, ref d))
            => a == c && b == d,
            (&Expression::Mul(ref a, ref b), &Expression::Mul(ref c, ref d))
            => a == c && b == d,
            (&Expression::Div(ref a, ref b), &Expression::Div(ref c, ref d))
            => a == c && b == d,
            (&Expression::Add(ref a, ref b), &Expression::Add(ref c, ref d))
            => a == c && b == d,
            (&Expression::Sub(ref a, ref b), &Expression::Sub(ref c, ref d))
            => a == c && b == d,
            (&Expression::Neg(ref a), &Expression::Neg(ref b)) => a == b,
            (&Expression::Error(ref a), &Expression::Error(ref b)) => a == b,
            _ => false,
        }
    }
}
/// Debug printing
impl fmt::Debug for Expression {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            &Expression::Value(ref a) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Value(",
                                                                ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a,) {
                                                           (__arg0,) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            &Expression::Exp(ref a, ref b) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Exp(",
                                                                ", ", ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a, &b) {
                                                           (__arg0, __arg1) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt),
                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            &Expression::Mul(ref a, ref b) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Mul(",
                                                                ", ", ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a, &b) {
                                                           (__arg0, __arg1) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt),
                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            &Expression::Div(ref a, ref b) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Div(",
                                                                ", ", ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a, &b) {
                                                           (__arg0, __arg1) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt),
                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            &Expression::Add(ref a, ref b) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Add(",
                                                                ", ", ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a, &b) {
                                                           (__arg0, __arg1) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt),
                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            &Expression::Sub(ref a, ref b) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Sub(",
                                                                ", ", ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a, &b) {
                                                           (__arg0, __arg1) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt),
                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            &Expression::Neg(ref a) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Neg(",
                                                                ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a,) {
                                                           (__arg0,) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            &Expression::Call(_, ref a) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Call(fn, ",
                                                                ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a,) {
                                                           (__arg0,) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            &Expression::Error(ref a) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["Expression::Error(",
                                                                ")"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a,) {
                                                           (__arg0,) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
        }
    }
}
/// Display an Expression as a string (equivalent of toString())
impl fmt::Display for Expression {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            &Expression::Value(ref a) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &[""];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a,) {
                                                           (__arg0,) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Display::fmt)],
                                                       })),
            &Expression::Error(ref a) =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &[""];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match (&a,) {
                                                           (__arg0,) =>
                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                        ::std::fmt::Debug::fmt)],
                                                       })),
            _ =>
            f.write_fmt(::std::fmt::Arguments::new_v1({
                                                          static __STATIC_FMTSTR:
                                                                 &'static [&'static str]
                                                                 =
                                                              &["unknown"];
                                                          __STATIC_FMTSTR
                                                      },
                                                      &match () {
                                                           () => [],
                                                       })),
        }
    }
}
impl Expression {
    /// Is this expression a known value
    #[inline]
    pub fn is_known(&self) -> bool {
        match self { &Expression::Value(_) => true, _ => false, }
    }
    /// Is this expression an error
    #[inline]
    pub fn is_error(&self) -> bool {
        match self { &Expression::Error(_) => true, _ => false, }
    }
    /// Extract a value or panic! (forcibly terminates the thread)
    #[inline]
    pub fn extract_value(&self) -> uval::UnitValue {
        match self {
            &Expression::Value(a) => a,
            _ => {
                ::std::rt::begin_unwind("extract value of unknown",
                                        {
                                            static _FILE_LINE:
                                                   (&'static str, u32) =
                                                ("src/main.rs", 169u32);
                                            &_FILE_LINE
                                        })
            }
        }
    }
    /// Extract a floating-point value or panic!
    #[inline]
    pub fn extract_float(&self) -> f64 {
        match self {
            &Expression::Value(a) => a.as_float(),
            _ => {
                ::std::rt::begin_unwind("extract value of unknown",
                                        {
                                            static _FILE_LINE:
                                                   (&'static str, u32) =
                                                ("src/main.rs", 177u32);
                                            &_FILE_LINE
                                        })
            }
        }
    }
}
/// Lookup a unary function by name (for convenience)
pub fn get_unary_function(res: &[u8]) -> Option<Box<Fn(f64) -> f64>> {
    match res {
        b"sin" => Some(Box::new(f64::sin)),
        b"cos" => Some(Box::new(f64::cos)),
        b"tan" => Some(Box::new(f64::tan)),
        _ => None,
    }
}
/// Get a function by name (including multi-argument functions)
pub fn get_function(res: &[u8]) -> Option<Box<Fn(Vec<f64>) -> f64>> {
    if let Some(f) = get_unary_function(res) {
        return Some(Box::new(move |a: Vec<f64>| f(a[0])))
    }
    match res {
        b"atan2" => Some(Box::new(|a: Vec<f64>| a[0].atan2(a[1]))),
        _ => None,
    }
}
/// Calculator state
pub struct Calculator {
    pub warnings: Vec<String>,
    pub result: Result<Expression, CalculatorError>,
}
/// Errors during calculation
#[structural_match]
pub enum CalculatorError {

    /// Caused by division by zero
    DivideByZeroError,

    /// Caused by an invalid argument
    DomainError,

    /// Caused by overflow
    OverflowError,

    /// Incompatible units or invalid use of units
    UnitError,

    /// Syntax Error
    SyntaxError,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::std::clone::Clone for CalculatorError {
    #[inline]
    fn clone(&self) -> CalculatorError {
        match (&*self,) {
            (&CalculatorError::DivideByZeroError,) => { *self }
            (&CalculatorError::DomainError,) => { *self }
            (&CalculatorError::OverflowError,) => { *self }
            (&CalculatorError::UnitError,) => { *self }
            (&CalculatorError::SyntaxError,) => { *self }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::std::marker::Copy for CalculatorError { }
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::std::hash::Hash for CalculatorError {
    fn hash<__H: ::std::hash::Hasher>(&self, __arg_0: &mut __H) -> () {
        match (&*self,) {
            (&CalculatorError::DivideByZeroError,) => {
                ::std::hash::Hash::hash(&unsafe {
                                             ::std::intrinsics::discriminant_value(self)
                                         }, __arg_0);
            }
            (&CalculatorError::DomainError,) => {
                ::std::hash::Hash::hash(&unsafe {
                                             ::std::intrinsics::discriminant_value(self)
                                         }, __arg_0);
            }
            (&CalculatorError::OverflowError,) => {
                ::std::hash::Hash::hash(&unsafe {
                                             ::std::intrinsics::discriminant_value(self)
                                         }, __arg_0);
            }
            (&CalculatorError::UnitError,) => {
                ::std::hash::Hash::hash(&unsafe {
                                             ::std::intrinsics::discriminant_value(self)
                                         }, __arg_0);
            }
            (&CalculatorError::SyntaxError,) => {
                ::std::hash::Hash::hash(&unsafe {
                                             ::std::intrinsics::discriminant_value(self)
                                         }, __arg_0);
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::std::cmp::Eq for CalculatorError {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        match (&*self,) {
            (&CalculatorError::DivideByZeroError,) => { }
            (&CalculatorError::DomainError,) => { }
            (&CalculatorError::OverflowError,) => { }
            (&CalculatorError::UnitError,) => { }
            (&CalculatorError::SyntaxError,) => { }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::std::cmp::PartialEq for CalculatorError {
    #[inline]
    fn eq(&self, __arg_0: &CalculatorError) -> bool {
        {
            let __self_vi =
                unsafe { ::std::intrinsics::discriminant_value(&*self) } as
                    isize;
            let __arg_1_vi =
                unsafe { ::std::intrinsics::discriminant_value(&*__arg_0) } as
                    isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*__arg_0) {
                    (&CalculatorError::DivideByZeroError,
                     &CalculatorError::DivideByZeroError) => true,
                    (&CalculatorError::DomainError,
                     &CalculatorError::DomainError) => true,
                    (&CalculatorError::OverflowError,
                     &CalculatorError::OverflowError) => true,
                    (&CalculatorError::UnitError, &CalculatorError::UnitError)
                    => true,
                    (&CalculatorError::SyntaxError,
                     &CalculatorError::SyntaxError) => true,
                    _ => unsafe { ::std::intrinsics::unreachable() }
                }
            } else { false }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::std::fmt::Debug for CalculatorError {
    fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match (&*self,) {
            (&CalculatorError::DivideByZeroError,) => {
                let mut builder = __arg_0.debug_tuple("DivideByZeroError");
                builder.finish()
            }
            (&CalculatorError::DomainError,) => {
                let mut builder = __arg_0.debug_tuple("DomainError");
                builder.finish()
            }
            (&CalculatorError::OverflowError,) => {
                let mut builder = __arg_0.debug_tuple("OverflowError");
                builder.finish()
            }
            (&CalculatorError::UnitError,) => {
                let mut builder = __arg_0.debug_tuple("UnitError");
                builder.finish()
            }
            (&CalculatorError::SyntaxError,) => {
                let mut builder = __arg_0.debug_tuple("SyntaxError");
                builder.finish()
            }
        }
    }
}
impl From<value::ArithmeticError> for CalculatorError {
    fn from(e: value::ArithmeticError) -> CalculatorError {
        match e {
            value::ArithmeticError::DivideByZeroError =>
            CalculatorError::DivideByZeroError,
            value::ArithmeticError::DomainError =>
            CalculatorError::DomainError,
            value::ArithmeticError::OverflowError =>
            CalculatorError::OverflowError,
            value::ArithmeticError::UnitError => CalculatorError::UnitError,
        }
    }
}
impl Calculator {
    fn new() -> Calculator {
        Calculator{warnings: Vec::new(),
                   result: Err(CalculatorError::SyntaxError),}
    }
    fn calculate(input: &mut String) -> Calculator {
        let mut calc = Calculator::new();
        input.push('?');
        calc.result =
            match calc.input(input.as_bytes()) {
                (_, IResult::Done(_, val)) =>
                match &val {
                    &Expression::Error(a) => Err(From::from(a)),
                    _ => Ok(val),
                },
                _ => Err(CalculatorError::SyntaxError),
            };
        calc
    }
    pub fn parens<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], Expression, u32>) {
        let result =
            {
                {
                    let res =
                        {
                            match {
                                      use ::nom::InputLength;
                                      match {
                                                if i.is_empty() {
                                                    let res:
                                                            ::nom::IResult<&[u8],
                                                                           char> =
                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                    res
                                                } else {
                                                    if i[0] == ('(' as u8) {
                                                        ::nom::IResult::Done(&i[1..],
                                                                             i[0]
                                                                                 as
                                                                                 char)
                                                    } else {
                                                        ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                   i))
                                                    }
                                                }
                                            } {
                                          ::nom::IResult::Error(e) =>
                                          ::nom::IResult::Error(e),
                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                          =>
                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                          =>
                                          ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                             +
                                                                                             i)),
                                          ::nom::IResult::Done(i, o) => {
                                              {
                                                  use ::nom::InputLength;
                                                  match {
                                                            match {
                                                                      {
                                                                          use ::nom::InputLength;
                                                                          match {
                                                                                    match multispace(i)
                                                                                        {
                                                                                        ::nom::IResult::Done(i,
                                                                                                             o)
                                                                                        =>
                                                                                        ::nom::IResult::Done(i,
                                                                                                             ::std::option::Option::Some(o)),
                                                                                        ::nom::IResult::Error(_)
                                                                                        =>
                                                                                        ::nom::IResult::Done(i,
                                                                                                             ::std::option::Option::None),
                                                                                        ::nom::IResult::Incomplete(i)
                                                                                        =>
                                                                                        ::nom::IResult::Incomplete(i),
                                                                                    }
                                                                                }
                                                                              {
                                                                              ::nom::IResult::Error(e)
                                                                              =>
                                                                              ::nom::IResult::Error(e),
                                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                              =>
                                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                              =>
                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                 +
                                                                                                                                 i)),
                                                                              ::nom::IResult::Done(i,
                                                                                                   o)
                                                                              =>
                                                                              {
                                                                                  {
                                                                                      use ::nom::InputLength;
                                                                                      match {
                                                                                                let (tmp,
                                                                                                     res) =
                                                                                                    self.expr(i);
                                                                                                self
                                                                                                    =
                                                                                                    tmp;
                                                                                                res
                                                                                            }
                                                                                          {
                                                                                          ::nom::IResult::Error(e)
                                                                                          =>
                                                                                          ::nom::IResult::Error(e),
                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                          =>
                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                          =>
                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                             +
                                                                                                                                             ((i).input_len()
                                                                                                                                                  -
                                                                                                                                                  i.input_len())
                                                                                                                                             +
                                                                                                                                             i)),
                                                                                          ::nom::IResult::Done(i,
                                                                                                               o)
                                                                                          =>
                                                                                          {
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   (o,
                                                                                                                    o))
                                                                                          }
                                                                                      }
                                                                                  }
                                                                              }
                                                                          }
                                                                      }
                                                                  } {
                                                                ::nom::IResult::Error(a)
                                                                =>
                                                                ::nom::IResult::Error(a),
                                                                ::nom::IResult::Incomplete(i)
                                                                =>
                                                                ::nom::IResult::Incomplete(i),
                                                                ::nom::IResult::Done(remaining,
                                                                                     (_,
                                                                                      o))
                                                                => {
                                                                    ::nom::IResult::Done(remaining,
                                                                                         o)
                                                                }
                                                            }
                                                        } {
                                                      ::nom::IResult::Error(e)
                                                      =>
                                                      ::nom::IResult::Error(e),
                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                      =>
                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                      =>
                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         i)),
                                                      ::nom::IResult::Done(i,
                                                                           o)
                                                      => {
                                                          {
                                                              use ::nom::InputLength;
                                                              match {
                                                                        match {
                                                                                  {
                                                                                      use ::nom::InputLength;
                                                                                      match {
                                                                                                match multispace(i)
                                                                                                    {
                                                                                                    ::nom::IResult::Done(i,
                                                                                                                         o)
                                                                                                    =>
                                                                                                    ::nom::IResult::Done(i,
                                                                                                                         ::std::option::Option::Some(o)),
                                                                                                    ::nom::IResult::Error(_)
                                                                                                    =>
                                                                                                    ::nom::IResult::Done(i,
                                                                                                                         ::std::option::Option::None),
                                                                                                    ::nom::IResult::Incomplete(i)
                                                                                                    =>
                                                                                                    ::nom::IResult::Incomplete(i),
                                                                                                }
                                                                                            }
                                                                                          {
                                                                                          ::nom::IResult::Error(e)
                                                                                          =>
                                                                                          ::nom::IResult::Error(e),
                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                          =>
                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                          =>
                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                             +
                                                                                                                                             i)),
                                                                                          ::nom::IResult::Done(i,
                                                                                                               o)
                                                                                          =>
                                                                                          {
                                                                                              {
                                                                                                  use ::nom::InputLength;
                                                                                                  match {
                                                                                                            if i.is_empty()
                                                                                                               {
                                                                                                                let res:
                                                                                                                        ::nom::IResult<&[u8],
                                                                                                                                       char> =
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                                                res
                                                                                                            } else {
                                                                                                                if i[0]
                                                                                                                       ==
                                                                                                                       (')'
                                                                                                                            as
                                                                                                                            u8)
                                                                                                                   {
                                                                                                                    ::nom::IResult::Done(&i[1..],
                                                                                                                                         i[0]
                                                                                                                                             as
                                                                                                                                             char)
                                                                                                                } else {
                                                                                                                    ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                                               i))
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                      {
                                                                                                      ::nom::IResult::Error(e)
                                                                                                      =>
                                                                                                      ::nom::IResult::Error(e),
                                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                      =>
                                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                      =>
                                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                         +
                                                                                                                                                         ((i).input_len()
                                                                                                                                                              -
                                                                                                                                                              i.input_len())
                                                                                                                                                         +
                                                                                                                                                         i)),
                                                                                                      ::nom::IResult::Done(i,
                                                                                                                           o)
                                                                                                      =>
                                                                                                      {
                                                                                                          ::nom::IResult::Done(i,
                                                                                                                               (o,
                                                                                                                                o))
                                                                                                      }
                                                                                                  }
                                                                                              }
                                                                                          }
                                                                                      }
                                                                                  }
                                                                              }
                                                                            {
                                                                            ::nom::IResult::Error(a)
                                                                            =>
                                                                            ::nom::IResult::Error(a),
                                                                            ::nom::IResult::Incomplete(i)
                                                                            =>
                                                                            ::nom::IResult::Incomplete(i),
                                                                            ::nom::IResult::Done(remaining,
                                                                                                 (_,
                                                                                                  o))
                                                                            =>
                                                                            {
                                                                                ::nom::IResult::Done(remaining,
                                                                                                     o)
                                                                            }
                                                                        }
                                                                    } {
                                                                  ::nom::IResult::Error(e)
                                                                  =>
                                                                  ::nom::IResult::Error(e),
                                                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                  =>
                                                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                  ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                  =>
                                                                  ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     i)),
                                                                  ::nom::IResult::Done(i,
                                                                                       o)
                                                                  => {
                                                                      ::nom::IResult::Done(i,
                                                                                           (o,
                                                                                            o,
                                                                                            o))
                                                                  }
                                                              }
                                                          }
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  } {
                                ::nom::IResult::Error(a) =>
                                ::nom::IResult::Error(a),
                                ::nom::IResult::Incomplete(i) =>
                                ::nom::IResult::Incomplete(i),
                                ::nom::IResult::Done(i1, (_, o, _)) => {
                                    ::nom::IResult::Done(i1, o)
                                }
                            }
                        };
                    match res {
                        ::nom::IResult::Done(_, _) => res,
                        ::nom::IResult::Incomplete(_) => res,
                        _ => {
                            match {
                                      {
                                          use ::nom::InputLength;
                                          match {
                                                    match alphanumeric(i) {
                                                        ::nom::IResult::Error(e)
                                                        =>
                                                        ::nom::IResult::Error(e),
                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                        =>
                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                        =>
                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i)),
                                                        ::nom::IResult::Done(i,
                                                                             o)
                                                        =>
                                                        match get_function(o)
                                                            {
                                                            ::std::option::Option::Some(output)
                                                            =>
                                                            ::nom::IResult::Done(i,
                                                                                 output),
                                                            ::std::option::Option::None
                                                            =>
                                                            ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::MapOpt,
                                                                                                       i)),
                                                        },
                                                    }
                                                } {
                                              ::nom::IResult::Error(e) =>
                                              ::nom::IResult::Error(e),
                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                              =>
                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                              =>
                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                 +
                                                                                                 i)),
                                              ::nom::IResult::Done(i, o) => {
                                                  let func = o;
                                                  match {
                                                            match {
                                                                      use ::nom::InputLength;
                                                                      match {
                                                                                if i.is_empty()
                                                                                   {
                                                                                    let res:
                                                                                            ::nom::IResult<&[u8],
                                                                                                           char> =
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                    res
                                                                                } else {
                                                                                    if i[0]
                                                                                           ==
                                                                                           ('('
                                                                                                as
                                                                                                u8)
                                                                                       {
                                                                                        ::nom::IResult::Done(&i[1..],
                                                                                                             i[0]
                                                                                                                 as
                                                                                                                 char)
                                                                                    } else {
                                                                                        ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                   i))
                                                                                    }
                                                                                }
                                                                            }
                                                                          {
                                                                          ::nom::IResult::Error(e)
                                                                          =>
                                                                          ::nom::IResult::Error(e),
                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                          =>
                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                          =>
                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                             +
                                                                                                                             i)),
                                                                          ::nom::IResult::Done(i,
                                                                                               o)
                                                                          => {
                                                                              {
                                                                                  use ::nom::InputLength;
                                                                                  match {
                                                                                            match {
                                                                                                      {
                                                                                                          use ::nom::InputLength;
                                                                                                          match {
                                                                                                                    match multispace(i)
                                                                                                                        {
                                                                                                                        ::nom::IResult::Done(i,
                                                                                                                                             o)
                                                                                                                        =>
                                                                                                                        ::nom::IResult::Done(i,
                                                                                                                                             ::std::option::Option::Some(o)),
                                                                                                                        ::nom::IResult::Error(_)
                                                                                                                        =>
                                                                                                                        ::nom::IResult::Done(i,
                                                                                                                                             ::std::option::Option::None),
                                                                                                                        ::nom::IResult::Incomplete(i)
                                                                                                                        =>
                                                                                                                        ::nom::IResult::Incomplete(i),
                                                                                                                    }
                                                                                                                }
                                                                                                              {
                                                                                                              ::nom::IResult::Error(e)
                                                                                                              =>
                                                                                                              ::nom::IResult::Error(e),
                                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                              =>
                                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                              =>
                                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                 +
                                                                                                                                                                 i)),
                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                   o)
                                                                                                              =>
                                                                                                              {
                                                                                                                  {
                                                                                                                      use ::nom::InputLength;
                                                                                                                      match {
                                                                                                                                let mut res =
                                                                                                                                    ::std::vec::Vec::new();
                                                                                                                                let mut input =
                                                                                                                                    i;
                                                                                                                                match {
                                                                                                                                          let (tmp,
                                                                                                                                               res) =
                                                                                                                                              self.expr(input);
                                                                                                                                          self
                                                                                                                                              =
                                                                                                                                              tmp;
                                                                                                                                          res
                                                                                                                                      }
                                                                                                                                    {
                                                                                                                                    ::nom::IResult::Error(a)
                                                                                                                                    =>
                                                                                                                                    ::nom::IResult::Error(a),
                                                                                                                                    ::nom::IResult::Incomplete(i)
                                                                                                                                    =>
                                                                                                                                    ::nom::IResult::Incomplete(i),
                                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                                         o)
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                        if i.len()
                                                                                                                                               ==
                                                                                                                                               input.len()
                                                                                                                                           {
                                                                                                                                            ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::SeparatedNonEmptyList,
                                                                                                                                                                                       input))
                                                                                                                                        } else {
                                                                                                                                            res.push(o);
                                                                                                                                            input
                                                                                                                                                =
                                                                                                                                                i;
                                                                                                                                            loop
                                                                                                                                                 {
                                                                                                                                                if let ::nom::IResult::Done(i2,
                                                                                                                                                                            _)
                                                                                                                                                       =
                                                                                                                                                       {
                                                                                                                                                           match {
                                                                                                                                                                     use ::nom::InputLength;
                                                                                                                                                                     match {
                                                                                                                                                                               match multispace(input)
                                                                                                                                                                                   {
                                                                                                                                                                                   ::nom::IResult::Done(i,
                                                                                                                                                                                                        o)
                                                                                                                                                                                   =>
                                                                                                                                                                                   ::nom::IResult::Done(i,
                                                                                                                                                                                                        ::std::option::Option::Some(o)),
                                                                                                                                                                                   ::nom::IResult::Error(_)
                                                                                                                                                                                   =>
                                                                                                                                                                                   ::nom::IResult::Done(input,
                                                                                                                                                                                                        ::std::option::Option::None),
                                                                                                                                                                                   ::nom::IResult::Incomplete(i)
                                                                                                                                                                                   =>
                                                                                                                                                                                   ::nom::IResult::Incomplete(i),
                                                                                                                                                                               }
                                                                                                                                                                           }
                                                                                                                                                                         {
                                                                                                                                                                         ::nom::IResult::Error(e)
                                                                                                                                                                         =>
                                                                                                                                                                         ::nom::IResult::Error(e),
                                                                                                                                                                         ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                                                                         =>
                                                                                                                                                                         ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                                                                         ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                                                                         =>
                                                                                                                                                                         ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                                                                            +
                                                                                                                                                                                                                            i)),
                                                                                                                                                                         ::nom::IResult::Done(i,
                                                                                                                                                                                              o)
                                                                                                                                                                         =>
                                                                                                                                                                         {
                                                                                                                                                                             {
                                                                                                                                                                                 use ::nom::InputLength;
                                                                                                                                                                                 match {
                                                                                                                                                                                           if i.is_empty()
                                                                                                                                                                                              {
                                                                                                                                                                                               let res:
                                                                                                                                                                                                       ::nom::IResult<&[u8],
                                                                                                                                                                                                                      char> =
                                                                                                                                                                                                   ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                                                                                                                               res
                                                                                                                                                                                           } else {
                                                                                                                                                                                               if i[0]
                                                                                                                                                                                                      ==
                                                                                                                                                                                                      (','
                                                                                                                                                                                                           as
                                                                                                                                                                                                           u8)
                                                                                                                                                                                                  {
                                                                                                                                                                                                   ::nom::IResult::Done(&i[1..],
                                                                                                                                                                                                                        i[0]
                                                                                                                                                                                                                            as
                                                                                                                                                                                                                            char)
                                                                                                                                                                                               } else {
                                                                                                                                                                                                   ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                                                                                                                              i))
                                                                                                                                                                                               }
                                                                                                                                                                                           }
                                                                                                                                                                                       }
                                                                                                                                                                                     {
                                                                                                                                                                                     ::nom::IResult::Error(e)
                                                                                                                                                                                     =>
                                                                                                                                                                                     ::nom::IResult::Error(e),
                                                                                                                                                                                     ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                                                                                     =>
                                                                                                                                                                                     ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                                                                                     ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                                                                                     =>
                                                                                                                                                                                     ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                                                                                        +
                                                                                                                                                                                                                                        ((input).input_len()
                                                                                                                                                                                                                                             -
                                                                                                                                                                                                                                             i.input_len())
                                                                                                                                                                                                                                        +
                                                                                                                                                                                                                                        i)),
                                                                                                                                                                                     ::nom::IResult::Done(i,
                                                                                                                                                                                                          o)
                                                                                                                                                                                     =>
                                                                                                                                                                                     {
                                                                                                                                                                                         {
                                                                                                                                                                                             use ::nom::InputLength;
                                                                                                                                                                                             match {
                                                                                                                                                                                                       match multispace(i)
                                                                                                                                                                                                           {
                                                                                                                                                                                                           ::nom::IResult::Done(i,
                                                                                                                                                                                                                                o)
                                                                                                                                                                                                           =>
                                                                                                                                                                                                           ::nom::IResult::Done(i,
                                                                                                                                                                                                                                ::std::option::Option::Some(o)),
                                                                                                                                                                                                           ::nom::IResult::Error(_)
                                                                                                                                                                                                           =>
                                                                                                                                                                                                           ::nom::IResult::Done(i,
                                                                                                                                                                                                                                ::std::option::Option::None),
                                                                                                                                                                                                           ::nom::IResult::Incomplete(i)
                                                                                                                                                                                                           =>
                                                                                                                                                                                                           ::nom::IResult::Incomplete(i),
                                                                                                                                                                                                       }
                                                                                                                                                                                                   }
                                                                                                                                                                                                 {
                                                                                                                                                                                                 ::nom::IResult::Error(e)
                                                                                                                                                                                                 =>
                                                                                                                                                                                                 ::nom::IResult::Error(e),
                                                                                                                                                                                                 ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                                                                                                 =>
                                                                                                                                                                                                 ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                                                                                                 ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                                                                                                 =>
                                                                                                                                                                                                 ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                                                                                                    +
                                                                                                                                                                                                                                                    ((input).input_len()
                                                                                                                                                                                                                                                         -
                                                                                                                                                                                                                                                         i.input_len())
                                                                                                                                                                                                                                                    +
                                                                                                                                                                                                                                                    ((i).input_len()
                                                                                                                                                                                                                                                         -
                                                                                                                                                                                                                                                         i.input_len())
                                                                                                                                                                                                                                                    +
                                                                                                                                                                                                                                                    i)),
                                                                                                                                                                                                 ::nom::IResult::Done(i,
                                                                                                                                                                                                                      o)
                                                                                                                                                                                                 =>
                                                                                                                                                                                                 {
                                                                                                                                                                                                     ::nom::IResult::Done(i,
                                                                                                                                                                                                                          (o,
                                                                                                                                                                                                                           o,
                                                                                                                                                                                                                           o))
                                                                                                                                                                                                 }
                                                                                                                                                                                             }
                                                                                                                                                                                         }
                                                                                                                                                                                     }
                                                                                                                                                                                 }
                                                                                                                                                                             }
                                                                                                                                                                         }
                                                                                                                                                                     }
                                                                                                                                                                 }
                                                                                                                                                               {
                                                                                                                                                               ::nom::IResult::Error(a)
                                                                                                                                                               =>
                                                                                                                                                               ::nom::IResult::Error(a),
                                                                                                                                                               ::nom::IResult::Incomplete(i)
                                                                                                                                                               =>
                                                                                                                                                               ::nom::IResult::Incomplete(i),
                                                                                                                                                               ::nom::IResult::Done(i1,
                                                                                                                                                                                    (_,
                                                                                                                                                                                     o,
                                                                                                                                                                                     _))
                                                                                                                                                               =>
                                                                                                                                                               {
                                                                                                                                                                   ::nom::IResult::Done(i1,
                                                                                                                                                                                        o)
                                                                                                                                                               }
                                                                                                                                                           }
                                                                                                                                                       }
                                                                                                                                                       {
                                                                                                                                                    if i2.len()
                                                                                                                                                           ==
                                                                                                                                                           input.len()
                                                                                                                                                       {
                                                                                                                                                        break
                                                                                                                                                            ;
                                                                                                                                                    }
                                                                                                                                                    input
                                                                                                                                                        =
                                                                                                                                                        i2;
                                                                                                                                                    if let ::nom::IResult::Done(i3,
                                                                                                                                                                                o3)
                                                                                                                                                           =
                                                                                                                                                           {
                                                                                                                                                               let (tmp,
                                                                                                                                                                    res) =
                                                                                                                                                                   self.expr(input);
                                                                                                                                                               self
                                                                                                                                                                   =
                                                                                                                                                                   tmp;
                                                                                                                                                               res
                                                                                                                                                           }
                                                                                                                                                           {
                                                                                                                                                        if i3.len()
                                                                                                                                                               ==
                                                                                                                                                               input.len()
                                                                                                                                                           {
                                                                                                                                                            break
                                                                                                                                                                ;
                                                                                                                                                        }
                                                                                                                                                        res.push(o3);
                                                                                                                                                        input
                                                                                                                                                            =
                                                                                                                                                            i3;
                                                                                                                                                    } else {
                                                                                                                                                        break
                                                                                                                                                            ;
                                                                                                                                                    }
                                                                                                                                                } else {
                                                                                                                                                    break
                                                                                                                                                        ;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            ::nom::IResult::Done(input,
                                                                                                                                                                 res)
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                          {
                                                                                                                          ::nom::IResult::Error(e)
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Error(e),
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                             +
                                                                                                                                                                             ((i).input_len()
                                                                                                                                                                                  -
                                                                                                                                                                                  i.input_len())
                                                                                                                                                                             +
                                                                                                                                                                             i)),
                                                                                                                          ::nom::IResult::Done(i,
                                                                                                                                               o)
                                                                                                                          =>
                                                                                                                          {
                                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                                   (o,
                                                                                                                                                    o))
                                                                                                                          }
                                                                                                                      }
                                                                                                                  }
                                                                                                              }
                                                                                                          }
                                                                                                      }
                                                                                                  }
                                                                                                {
                                                                                                ::nom::IResult::Error(a)
                                                                                                =>
                                                                                                ::nom::IResult::Error(a),
                                                                                                ::nom::IResult::Incomplete(i)
                                                                                                =>
                                                                                                ::nom::IResult::Incomplete(i),
                                                                                                ::nom::IResult::Done(remaining,
                                                                                                                     (_,
                                                                                                                      o))
                                                                                                =>
                                                                                                {
                                                                                                    ::nom::IResult::Done(remaining,
                                                                                                                         o)
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                      {
                                                                                      ::nom::IResult::Error(e)
                                                                                      =>
                                                                                      ::nom::IResult::Error(e),
                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                      =>
                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                      =>
                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                         +
                                                                                                                                         ((i).input_len()
                                                                                                                                              -
                                                                                                                                              i.input_len())
                                                                                                                                         +
                                                                                                                                         i)),
                                                                                      ::nom::IResult::Done(i,
                                                                                                           o)
                                                                                      =>
                                                                                      {
                                                                                          {
                                                                                              use ::nom::InputLength;
                                                                                              match {
                                                                                                        match {
                                                                                                                  {
                                                                                                                      use ::nom::InputLength;
                                                                                                                      match {
                                                                                                                                match multispace(i)
                                                                                                                                    {
                                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                                         o)
                                                                                                                                    =>
                                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                                         ::std::option::Option::Some(o)),
                                                                                                                                    ::nom::IResult::Error(_)
                                                                                                                                    =>
                                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                                         ::std::option::Option::None),
                                                                                                                                    ::nom::IResult::Incomplete(i)
                                                                                                                                    =>
                                                                                                                                    ::nom::IResult::Incomplete(i),
                                                                                                                                }
                                                                                                                            }
                                                                                                                          {
                                                                                                                          ::nom::IResult::Error(e)
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Error(e),
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                             +
                                                                                                                                                                             i)),
                                                                                                                          ::nom::IResult::Done(i,
                                                                                                                                               o)
                                                                                                                          =>
                                                                                                                          {
                                                                                                                              {
                                                                                                                                  use ::nom::InputLength;
                                                                                                                                  match {
                                                                                                                                            if i.is_empty()
                                                                                                                                               {
                                                                                                                                                let res:
                                                                                                                                                        ::nom::IResult<&[u8],
                                                                                                                                                                       char> =
                                                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                                                                                res
                                                                                                                                            } else {
                                                                                                                                                if i[0]
                                                                                                                                                       ==
                                                                                                                                                       (')'
                                                                                                                                                            as
                                                                                                                                                            u8)
                                                                                                                                                   {
                                                                                                                                                    ::nom::IResult::Done(&i[1..],
                                                                                                                                                                         i[0]
                                                                                                                                                                             as
                                                                                                                                                                             char)
                                                                                                                                                } else {
                                                                                                                                                    ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                                                                               i))
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                      {
                                                                                                                                      ::nom::IResult::Error(e)
                                                                                                                                      =>
                                                                                                                                      ::nom::IResult::Error(e),
                                                                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                                      =>
                                                                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                                      =>
                                                                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                                         +
                                                                                                                                                                                         ((i).input_len()
                                                                                                                                                                                              -
                                                                                                                                                                                              i.input_len())
                                                                                                                                                                                         +
                                                                                                                                                                                         i)),
                                                                                                                                      ::nom::IResult::Done(i,
                                                                                                                                                           o)
                                                                                                                                      =>
                                                                                                                                      {
                                                                                                                                          ::nom::IResult::Done(i,
                                                                                                                                                               (o,
                                                                                                                                                                o))
                                                                                                                                      }
                                                                                                                                  }
                                                                                                                              }
                                                                                                                          }
                                                                                                                      }
                                                                                                                  }
                                                                                                              }
                                                                                                            {
                                                                                                            ::nom::IResult::Error(a)
                                                                                                            =>
                                                                                                            ::nom::IResult::Error(a),
                                                                                                            ::nom::IResult::Incomplete(i)
                                                                                                            =>
                                                                                                            ::nom::IResult::Incomplete(i),
                                                                                                            ::nom::IResult::Done(remaining,
                                                                                                                                 (_,
                                                                                                                                  o))
                                                                                                            =>
                                                                                                            {
                                                                                                                ::nom::IResult::Done(remaining,
                                                                                                                                     o)
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                  {
                                                                                                  ::nom::IResult::Error(e)
                                                                                                  =>
                                                                                                  ::nom::IResult::Error(e),
                                                                                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                  =>
                                                                                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                  ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                  =>
                                                                                                  ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                     +
                                                                                                                                                     ((i).input_len()
                                                                                                                                                          -
                                                                                                                                                          i.input_len())
                                                                                                                                                     +
                                                                                                                                                     ((i).input_len()
                                                                                                                                                          -
                                                                                                                                                          i.input_len())
                                                                                                                                                     +
                                                                                                                                                     i)),
                                                                                                  ::nom::IResult::Done(i,
                                                                                                                       o)
                                                                                                  =>
                                                                                                  {
                                                                                                      ::nom::IResult::Done(i,
                                                                                                                           (o,
                                                                                                                            o,
                                                                                                                            o))
                                                                                                  }
                                                                                              }
                                                                                          }
                                                                                      }
                                                                                  }
                                                                              }
                                                                          }
                                                                      }
                                                                  } {
                                                                ::nom::IResult::Error(a)
                                                                =>
                                                                ::nom::IResult::Error(a),
                                                                ::nom::IResult::Incomplete(i)
                                                                =>
                                                                ::nom::IResult::Incomplete(i),
                                                                ::nom::IResult::Done(i1,
                                                                                     (_,
                                                                                      o,
                                                                                      _))
                                                                => {
                                                                    ::nom::IResult::Done(i1,
                                                                                         o)
                                                                }
                                                            }
                                                        } {
                                                      ::nom::IResult::Error(e)
                                                      =>
                                                      ::nom::IResult::Error(e),
                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                      =>
                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                      =>
                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         i)),
                                                      ::nom::IResult::Done(i,
                                                                           o)
                                                      => {
                                                          let args = o;
                                                          ::nom::IResult::Done(i,
                                                                               (||
                                                                                    simplify1(Expression::Call(func,
                                                                                                               args)))())
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  } {
                                ::nom::IResult::Done(i, o) =>
                                ::nom::IResult::Done(i, o),
                                ::nom::IResult::Incomplete(x) =>
                                ::nom::IResult::Incomplete(x),
                                ::nom::IResult::Error(_) => {
                                    ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Alt,
                                                                               i))
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
    fn recognize_number1<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], &[u8], u32>) {
        let result =
            {
                use ::nom::HexDisplay;
                match {
                          {
                              use ::nom::InputLength;
                              match Calculator::decimal(i) {
                                  ::nom::IResult::Error(e) =>
                                  ::nom::IResult::Error(e),
                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                  =>
                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                  ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                  =>
                                  ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                     +
                                                                                     i)),
                                  ::nom::IResult::Done(i, _) => {
                                      {
                                          {
                                              use ::nom::InputLength;
                                              let res =
                                                  {
                                                      match {
                                                                {
                                                                    use ::nom::InputLength;
                                                                    match {
                                                                              if i.is_empty()
                                                                                 {
                                                                                  let res:
                                                                                          ::nom::IResult<&[u8],
                                                                                                         char> =
                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                  res
                                                                              } else {
                                                                                  if i[0]
                                                                                         ==
                                                                                         ('.'
                                                                                              as
                                                                                              u8)
                                                                                     {
                                                                                      ::nom::IResult::Done(&i[1..],
                                                                                                           i[0]
                                                                                                               as
                                                                                                               char)
                                                                                  } else {
                                                                                      ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                 i))
                                                                                  }
                                                                              }
                                                                          } {
                                                                        ::nom::IResult::Error(e)
                                                                        =>
                                                                        ::nom::IResult::Error(e),
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                        =>
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                        =>
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                           +
                                                                                                                           i)),
                                                                        ::nom::IResult::Done(i,
                                                                                             o)
                                                                        => {
                                                                            {
                                                                                use ::nom::InputLength;
                                                                                match {
                                                                                          match Calculator::decimal(i)
                                                                                              {
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   o)
                                                                                              =>
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   ::std::option::Option::Some(o)),
                                                                                              ::nom::IResult::Error(_)
                                                                                              =>
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   ::std::option::Option::None),
                                                                                              ::nom::IResult::Incomplete(i)
                                                                                              =>
                                                                                              ::nom::IResult::Incomplete(i),
                                                                                          }
                                                                                      }
                                                                                    {
                                                                                    ::nom::IResult::Error(e)
                                                                                    =>
                                                                                    ::nom::IResult::Error(e),
                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                    =>
                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                    =>
                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                       +
                                                                                                                                       ((i).input_len()
                                                                                                                                            -
                                                                                                                                            i.input_len())
                                                                                                                                       +
                                                                                                                                       i)),
                                                                                    ::nom::IResult::Done(i,
                                                                                                         o)
                                                                                    =>
                                                                                    {
                                                                                        ::nom::IResult::Done(i,
                                                                                                             (o,
                                                                                                              o))
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            } {
                                                          ::nom::IResult::Error(a)
                                                          =>
                                                          ::nom::IResult::Error(a),
                                                          ::nom::IResult::Incomplete(i)
                                                          =>
                                                          ::nom::IResult::Incomplete(i),
                                                          ::nom::IResult::Done(remaining,
                                                                               (_,
                                                                                o))
                                                          => {
                                                              ::nom::IResult::Done(remaining,
                                                                                   o)
                                                          }
                                                      }
                                                  };
                                              if let ::nom::IResult::Incomplete(inc)
                                                     = res {
                                                  match inc {
                                                      ::nom::Needed::Unknown
                                                      =>
                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                      ::nom::Needed::Size(i)
                                                      =>
                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         i)),
                                                  }
                                              } else {
                                                  let input =
                                                      if let ::nom::IResult::Done(i,
                                                                                  _)
                                                             = res {
                                                          i
                                                      } else { i };
                                                  {
                                                      let res =
                                                          {
                                                              match {
                                                                        {
                                                                            use ::nom::InputLength;
                                                                            match {
                                                                                      if input.is_empty()
                                                                                         {
                                                                                          ::nom::IResult::Incomplete::<_,
                                                                                                                       _>(::nom::Needed::Size(1))
                                                                                      } else {
                                                                                          #[inline(always)]
                                                                                          fn as_bytes<T: ::nom::AsBytes>(b:
                                                                                                                             &T)
                                                                                           ->
                                                                                               &[u8] {
                                                                                              b.as_bytes()
                                                                                          }
                                                                                          let expected =
                                                                                              "eE";
                                                                                          let bytes =
                                                                                              as_bytes(&expected);
                                                                                          {
                                                                                              if input.is_empty()
                                                                                                 {
                                                                                                  ::nom::IResult::Incomplete::<_,
                                                                                                                               _>(::nom::Needed::Size(1))
                                                                                              } else {
                                                                                                  let mut found =
                                                                                                      false;
                                                                                                  for &i
                                                                                                      in
                                                                                                      bytes
                                                                                                      {
                                                                                                      if i
                                                                                                             ==
                                                                                                             input[0]
                                                                                                         {
                                                                                                          found
                                                                                                              =
                                                                                                              true;
                                                                                                          break
                                                                                                              ;
                                                                                                      }
                                                                                                  }
                                                                                                  if found
                                                                                                     {
                                                                                                      ::nom::IResult::Done(&input[1..],
                                                                                                                           input[0]
                                                                                                                               as
                                                                                                                               char)
                                                                                                  } else {
                                                                                                      ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::OneOf,
                                                                                                                                                 input))
                                                                                                  }
                                                                                              }
                                                                                          }
                                                                                      }
                                                                                  }
                                                                                {
                                                                                ::nom::IResult::Error(e)
                                                                                =>
                                                                                ::nom::IResult::Error(e),
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                =>
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                =>
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                   +
                                                                                                                                   i)),
                                                                                ::nom::IResult::Done(i,
                                                                                                     o)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        use ::nom::InputLength;
                                                                                        match {
                                                                                                  match {
                                                                                                            {
                                                                                                                use ::nom::InputLength;
                                                                                                                match {
                                                                                                                          match {
                                                                                                                                    if i.is_empty()
                                                                                                                                       {
                                                                                                                                        ::nom::IResult::Incomplete::<_,
                                                                                                                                                                     _>(::nom::Needed::Size(1))
                                                                                                                                    } else {
                                                                                                                                        #[inline(always)]
                                                                                                                                        fn as_bytes<T: ::nom::AsBytes>(b:
                                                                                                                                                                           &T)
                                                                                                                                         ->
                                                                                                                                             &[u8] {
                                                                                                                                            b.as_bytes()
                                                                                                                                        }
                                                                                                                                        let expected =
                                                                                                                                            "+-";
                                                                                                                                        let bytes =
                                                                                                                                            as_bytes(&expected);
                                                                                                                                        {
                                                                                                                                            if i.is_empty()
                                                                                                                                               {
                                                                                                                                                ::nom::IResult::Incomplete::<_,
                                                                                                                                                                             _>(::nom::Needed::Size(1))
                                                                                                                                            } else {
                                                                                                                                                let mut found =
                                                                                                                                                    false;
                                                                                                                                                for &i
                                                                                                                                                    in
                                                                                                                                                    bytes
                                                                                                                                                    {
                                                                                                                                                    if i
                                                                                                                                                           ==
                                                                                                                                                           i[0]
                                                                                                                                                       {
                                                                                                                                                        found
                                                                                                                                                            =
                                                                                                                                                            true;
                                                                                                                                                        break
                                                                                                                                                            ;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                if found
                                                                                                                                                   {
                                                                                                                                                    ::nom::IResult::Done(&i[1..],
                                                                                                                                                                         i[0]
                                                                                                                                                                             as
                                                                                                                                                                             char)
                                                                                                                                                } else {
                                                                                                                                                    ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::OneOf,
                                                                                                                                                                                               i))
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                              {
                                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                                   o)
                                                                                                                              =>
                                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                                   ::std::option::Option::Some(o)),
                                                                                                                              ::nom::IResult::Error(_)
                                                                                                                              =>
                                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                                   ::std::option::Option::None),
                                                                                                                              ::nom::IResult::Incomplete(i)
                                                                                                                              =>
                                                                                                                              ::nom::IResult::Incomplete(i),
                                                                                                                          }
                                                                                                                      }
                                                                                                                    {
                                                                                                                    ::nom::IResult::Error(e)
                                                                                                                    =>
                                                                                                                    ::nom::IResult::Error(e),
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                    =>
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                    =>
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                       +
                                                                                                                                                                       i)),
                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                         o)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            use ::nom::InputLength;
                                                                                                                            match Calculator::decimal(i)
                                                                                                                                {
                                                                                                                                ::nom::IResult::Error(e)
                                                                                                                                =>
                                                                                                                                ::nom::IResult::Error(e),
                                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                                =>
                                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                                =>
                                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                                   +
                                                                                                                                                                                   ((i).input_len()
                                                                                                                                                                                        -
                                                                                                                                                                                        i.input_len())
                                                                                                                                                                                   +
                                                                                                                                                                                   i)),
                                                                                                                                ::nom::IResult::Done(i,
                                                                                                                                                     o)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                                         (o,
                                                                                                                                                          o))
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                      {
                                                                                                      ::nom::IResult::Error(a)
                                                                                                      =>
                                                                                                      ::nom::IResult::Error(a),
                                                                                                      ::nom::IResult::Incomplete(i)
                                                                                                      =>
                                                                                                      ::nom::IResult::Incomplete(i),
                                                                                                      ::nom::IResult::Done(remaining,
                                                                                                                           (_,
                                                                                                                            o))
                                                                                                      =>
                                                                                                      {
                                                                                                          ::nom::IResult::Done(remaining,
                                                                                                                               o)
                                                                                                      }
                                                                                                  }
                                                                                              }
                                                                                            {
                                                                                            ::nom::IResult::Error(e)
                                                                                            =>
                                                                                            ::nom::IResult::Error(e),
                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                            =>
                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                            =>
                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                               +
                                                                                                                                               ((input).input_len()
                                                                                                                                                    -
                                                                                                                                                    i.input_len())
                                                                                                                                               +
                                                                                                                                               i)),
                                                                                            ::nom::IResult::Done(i,
                                                                                                                 o)
                                                                                            =>
                                                                                            {
                                                                                                ::nom::IResult::Done(i,
                                                                                                                     (o,
                                                                                                                      o))
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    } {
                                                                  ::nom::IResult::Error(a)
                                                                  =>
                                                                  ::nom::IResult::Error(a),
                                                                  ::nom::IResult::Incomplete(i)
                                                                  =>
                                                                  ::nom::IResult::Incomplete(i),
                                                                  ::nom::IResult::Done(remaining,
                                                                                       (_,
                                                                                        o))
                                                                  => {
                                                                      ::nom::IResult::Done(remaining,
                                                                                           o)
                                                                  }
                                                              }
                                                          };
                                                      if let ::nom::IResult::Incomplete(inc)
                                                             = res {
                                                          match inc {
                                                              ::nom::Needed::Unknown
                                                              =>
                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                              ::nom::Needed::Size(i)
                                                              =>
                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                 +
                                                                                                                 ((i).input_len()
                                                                                                                      -
                                                                                                                      i.input_len())
                                                                                                                 +
                                                                                                                 ((i).input_len()
                                                                                                                      -
                                                                                                                      input.input_len())
                                                                                                                 +
                                                                                                                 i)),
                                                          }
                                                      } else {
                                                          let input =
                                                              if let ::nom::IResult::Done(i,
                                                                                          _)
                                                                     = res {
                                                                  i
                                                              } else {
                                                                  input
                                                              };
                                                          ::nom::IResult::Done(input,
                                                                               (||
                                                                                    ())())
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  }
                              }
                          }
                      } {
                    ::nom::IResult::Done(i, _) => {
                        let index = (i).offset(i);
                        ::nom::IResult::Done(i, &(i)[..index])
                    }
                    ::nom::IResult::Error(e) =>
                    return ::nom::IResult::Error(e),
                    ::nom::IResult::Incomplete(i) =>
                    return ::nom::IResult::Incomplete(i),
                }
            };
        (self, result)
    }
    fn recognize_number2<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], &[u8], u32>) {
        let result =
            {
                use ::nom::HexDisplay;
                match {
                          {
                              use ::nom::InputLength;
                              match {
                                        if i.is_empty() {
                                            let res:
                                                    ::nom::IResult<&[u8],
                                                                   char> =
                                                ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                            res
                                        } else {
                                            if i[0] == ('.' as u8) {
                                                ::nom::IResult::Done(&i[1..],
                                                                     i[0] as
                                                                         char)
                                            } else {
                                                ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                           i))
                                            }
                                        }
                                    } {
                                  ::nom::IResult::Error(e) =>
                                  ::nom::IResult::Error(e),
                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                  =>
                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                  ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                  =>
                                  ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                     +
                                                                                     i)),
                                  ::nom::IResult::Done(i, _) => {
                                      {
                                          use ::nom::InputLength;
                                          match Calculator::decimal(i) {
                                              ::nom::IResult::Error(e) =>
                                              ::nom::IResult::Error(e),
                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                              =>
                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                              =>
                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                 +
                                                                                                 ((i).input_len()
                                                                                                      -
                                                                                                      i.input_len())
                                                                                                 +
                                                                                                 i)),
                                              ::nom::IResult::Done(i, _) => {
                                                  {
                                                      let res =
                                                          {
                                                              match {
                                                                        {
                                                                            use ::nom::InputLength;
                                                                            match {
                                                                                      if i.is_empty()
                                                                                         {
                                                                                          ::nom::IResult::Incomplete::<_,
                                                                                                                       _>(::nom::Needed::Size(1))
                                                                                      } else {
                                                                                          #[inline(always)]
                                                                                          fn as_bytes<T: ::nom::AsBytes>(b:
                                                                                                                             &T)
                                                                                           ->
                                                                                               &[u8] {
                                                                                              b.as_bytes()
                                                                                          }
                                                                                          let expected =
                                                                                              "eE";
                                                                                          let bytes =
                                                                                              as_bytes(&expected);
                                                                                          {
                                                                                              if i.is_empty()
                                                                                                 {
                                                                                                  ::nom::IResult::Incomplete::<_,
                                                                                                                               _>(::nom::Needed::Size(1))
                                                                                              } else {
                                                                                                  let mut found =
                                                                                                      false;
                                                                                                  for &i
                                                                                                      in
                                                                                                      bytes
                                                                                                      {
                                                                                                      if i
                                                                                                             ==
                                                                                                             i[0]
                                                                                                         {
                                                                                                          found
                                                                                                              =
                                                                                                              true;
                                                                                                          break
                                                                                                              ;
                                                                                                      }
                                                                                                  }
                                                                                                  if found
                                                                                                     {
                                                                                                      ::nom::IResult::Done(&i[1..],
                                                                                                                           i[0]
                                                                                                                               as
                                                                                                                               char)
                                                                                                  } else {
                                                                                                      ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::OneOf,
                                                                                                                                                 i))
                                                                                                  }
                                                                                              }
                                                                                          }
                                                                                      }
                                                                                  }
                                                                                {
                                                                                ::nom::IResult::Error(e)
                                                                                =>
                                                                                ::nom::IResult::Error(e),
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                =>
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                =>
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                   +
                                                                                                                                   i)),
                                                                                ::nom::IResult::Done(i,
                                                                                                     o)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        use ::nom::InputLength;
                                                                                        match {
                                                                                                  match {
                                                                                                            {
                                                                                                                use ::nom::InputLength;
                                                                                                                match {
                                                                                                                          match {
                                                                                                                                    if i.is_empty()
                                                                                                                                       {
                                                                                                                                        ::nom::IResult::Incomplete::<_,
                                                                                                                                                                     _>(::nom::Needed::Size(1))
                                                                                                                                    } else {
                                                                                                                                        #[inline(always)]
                                                                                                                                        fn as_bytes<T: ::nom::AsBytes>(b:
                                                                                                                                                                           &T)
                                                                                                                                         ->
                                                                                                                                             &[u8] {
                                                                                                                                            b.as_bytes()
                                                                                                                                        }
                                                                                                                                        let expected =
                                                                                                                                            "+-";
                                                                                                                                        let bytes =
                                                                                                                                            as_bytes(&expected);
                                                                                                                                        {
                                                                                                                                            if i.is_empty()
                                                                                                                                               {
                                                                                                                                                ::nom::IResult::Incomplete::<_,
                                                                                                                                                                             _>(::nom::Needed::Size(1))
                                                                                                                                            } else {
                                                                                                                                                let mut found =
                                                                                                                                                    false;
                                                                                                                                                for &i
                                                                                                                                                    in
                                                                                                                                                    bytes
                                                                                                                                                    {
                                                                                                                                                    if i
                                                                                                                                                           ==
                                                                                                                                                           i[0]
                                                                                                                                                       {
                                                                                                                                                        found
                                                                                                                                                            =
                                                                                                                                                            true;
                                                                                                                                                        break
                                                                                                                                                            ;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                if found
                                                                                                                                                   {
                                                                                                                                                    ::nom::IResult::Done(&i[1..],
                                                                                                                                                                         i[0]
                                                                                                                                                                             as
                                                                                                                                                                             char)
                                                                                                                                                } else {
                                                                                                                                                    ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::OneOf,
                                                                                                                                                                                               i))
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                              {
                                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                                   o)
                                                                                                                              =>
                                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                                   ::std::option::Option::Some(o)),
                                                                                                                              ::nom::IResult::Error(_)
                                                                                                                              =>
                                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                                   ::std::option::Option::None),
                                                                                                                              ::nom::IResult::Incomplete(i)
                                                                                                                              =>
                                                                                                                              ::nom::IResult::Incomplete(i),
                                                                                                                          }
                                                                                                                      }
                                                                                                                    {
                                                                                                                    ::nom::IResult::Error(e)
                                                                                                                    =>
                                                                                                                    ::nom::IResult::Error(e),
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                    =>
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                    =>
                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                       +
                                                                                                                                                                       i)),
                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                         o)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            use ::nom::InputLength;
                                                                                                                            match Calculator::decimal(i)
                                                                                                                                {
                                                                                                                                ::nom::IResult::Error(e)
                                                                                                                                =>
                                                                                                                                ::nom::IResult::Error(e),
                                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                                =>
                                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                                =>
                                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                                   +
                                                                                                                                                                                   ((i).input_len()
                                                                                                                                                                                        -
                                                                                                                                                                                        i.input_len())
                                                                                                                                                                                   +
                                                                                                                                                                                   i)),
                                                                                                                                ::nom::IResult::Done(i,
                                                                                                                                                     o)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                                         (o,
                                                                                                                                                          o))
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                      {
                                                                                                      ::nom::IResult::Error(a)
                                                                                                      =>
                                                                                                      ::nom::IResult::Error(a),
                                                                                                      ::nom::IResult::Incomplete(i)
                                                                                                      =>
                                                                                                      ::nom::IResult::Incomplete(i),
                                                                                                      ::nom::IResult::Done(remaining,
                                                                                                                           (_,
                                                                                                                            o))
                                                                                                      =>
                                                                                                      {
                                                                                                          ::nom::IResult::Done(remaining,
                                                                                                                               o)
                                                                                                      }
                                                                                                  }
                                                                                              }
                                                                                            {
                                                                                            ::nom::IResult::Error(e)
                                                                                            =>
                                                                                            ::nom::IResult::Error(e),
                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                            =>
                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                            =>
                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                               +
                                                                                                                                               ((i).input_len()
                                                                                                                                                    -
                                                                                                                                                    i.input_len())
                                                                                                                                               +
                                                                                                                                               i)),
                                                                                            ::nom::IResult::Done(i,
                                                                                                                 o)
                                                                                            =>
                                                                                            {
                                                                                                ::nom::IResult::Done(i,
                                                                                                                     (o,
                                                                                                                      o))
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    } {
                                                                  ::nom::IResult::Error(a)
                                                                  =>
                                                                  ::nom::IResult::Error(a),
                                                                  ::nom::IResult::Incomplete(i)
                                                                  =>
                                                                  ::nom::IResult::Incomplete(i),
                                                                  ::nom::IResult::Done(remaining,
                                                                                       (_,
                                                                                        o))
                                                                  => {
                                                                      ::nom::IResult::Done(remaining,
                                                                                           o)
                                                                  }
                                                              }
                                                          };
                                                      if let ::nom::IResult::Incomplete(inc)
                                                             = res {
                                                          match inc {
                                                              ::nom::Needed::Unknown
                                                              =>
                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                              ::nom::Needed::Size(i)
                                                              =>
                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                 +
                                                                                                                 ((i).input_len()
                                                                                                                      -
                                                                                                                      i.input_len())
                                                                                                                 +
                                                                                                                 ((i).input_len()
                                                                                                                      -
                                                                                                                      i.input_len())
                                                                                                                 +
                                                                                                                 i)),
                                                          }
                                                      } else {
                                                          let input =
                                                              if let ::nom::IResult::Done(i,
                                                                                          _)
                                                                     = res {
                                                                  i
                                                              } else { i };
                                                          ::nom::IResult::Done(input,
                                                                               (||
                                                                                    ())())
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  }
                              }
                          }
                      } {
                    ::nom::IResult::Done(i, _) => {
                        let index = (i).offset(i);
                        ::nom::IResult::Done(i, &(i)[..index])
                    }
                    ::nom::IResult::Error(e) =>
                    return ::nom::IResult::Error(e),
                    ::nom::IResult::Incomplete(i) =>
                    return ::nom::IResult::Incomplete(i),
                }
            };
        (self, result)
    }
    /// Convert a [u8] (char array) to a String
    #[inline]
    fn stringify_u8(res: &[u8]) -> Result<String, str::Utf8Error> {
        Ok(match str::from_utf8(res) {
               ::std::result::Result::Ok(val) => val,
               ::std::result::Result::Err(err) => {
                   return ::std::result::Result::Err(::std::convert::From::from(err))
               }
           }.to_owned())
    }
    /// Convert a [u8] to a String and add a 0 at the front (.2 -> 0.2)
    #[inline]
    fn prepend_zero(res: &[u8]) -> Result<String, str::Utf8Error> {
        let mut s =
            match str::from_utf8(res) {
                ::std::result::Result::Ok(val) => val,
                ::std::result::Result::Err(err) => {
                    return ::std::result::Result::Err(::std::convert::From::from(err))
                }
            }.to_owned();
        s.insert(0, '0');
        Ok(s)
    }
    fn decimal<'a>(i: &'a [u8]) -> ::nom::IResult<&'a [u8], (), u32> {
        {
            match {
                      use ::nom::InputLength;
                      match {
                                if i.is_empty() {
                                    ::nom::IResult::Incomplete::<_,
                                                                 _>(::nom::Needed::Size(1))
                                } else {
                                    #[inline(always)]
                                    fn as_bytes<T: ::nom::AsBytes>(b: &T)
                                     -> &[u8] {
                                        b.as_bytes()
                                    }
                                    let expected = "0123456789_";
                                    let bytes = as_bytes(&expected);
                                    {
                                        if i.is_empty() {
                                            ::nom::IResult::Incomplete::<_,
                                                                         _>(::nom::Needed::Size(1))
                                        } else {
                                            let mut found = false;
                                            for &i in bytes {
                                                if i == i[0] {
                                                    found = true;
                                                    break ;
                                                }
                                            }
                                            if found {
                                                ::nom::IResult::Done(&i[1..],
                                                                     i[0] as
                                                                         char)
                                            } else {
                                                ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::OneOf,
                                                                                           i))
                                            }
                                        }
                                    }
                                }
                            } {
                          ::nom::IResult::Error(_) =>
                          ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Many1,
                                                                     i)),
                          ::nom::IResult::Incomplete(i) =>
                          ::nom::IResult::Incomplete(i),
                          ::nom::IResult::Done(i1, o1) => {
                              if i1.len() == 0 {
                                  ::nom::IResult::Done(i1,
                                                       <[_]>::into_vec(box
                                                                           [o1]))
                              } else {
                                  let mut res =
                                      ::std::vec::Vec::with_capacity(4);
                                  res.push(o1);
                                  let mut input = i1;
                                  let mut incomplete:
                                          ::std::option::Option<::nom::Needed> =
                                      ::std::option::Option::None;
                                  loop  {
                                      if input.input_len() == 0 { break ; }
                                      match {
                                                if input.is_empty() {
                                                    ::nom::IResult::Incomplete::<_,
                                                                                 _>(::nom::Needed::Size(1))
                                                } else {
                                                    #[inline(always)]
                                                    fn as_bytes<T: ::nom::AsBytes>(b:
                                                                                       &T)
                                                     -> &[u8] {
                                                        b.as_bytes()
                                                    }
                                                    let expected =
                                                        "0123456789_";
                                                    let bytes =
                                                        as_bytes(&expected);
                                                    {
                                                        if input.is_empty() {
                                                            ::nom::IResult::Incomplete::<_,
                                                                                         _>(::nom::Needed::Size(1))
                                                        } else {
                                                            let mut found =
                                                                false;
                                                            for &i in bytes {
                                                                if i ==
                                                                       input[0]
                                                                   {
                                                                    found =
                                                                        true;
                                                                    break ;
                                                                }
                                                            }
                                                            if found {
                                                                ::nom::IResult::Done(&input[1..],
                                                                                     input[0]
                                                                                         as
                                                                                         char)
                                                            } else {
                                                                ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::OneOf,
                                                                                                           input))
                                                            }
                                                        }
                                                    }
                                                }
                                            } {
                                          ::nom::IResult::Error(_) => {
                                              break ;
                                          }
                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                          => {
                                              incomplete =
                                                  ::std::option::Option::Some(::nom::Needed::Unknown);
                                              break ;
                                          }
                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                          => {
                                              incomplete =
                                                  ::std::option::Option::Some(::nom::Needed::Size(i
                                                                                                      +
                                                                                                      (i).input_len()
                                                                                                      -
                                                                                                      input.input_len()));
                                              break ;
                                          }
                                          ::nom::IResult::Done(i, o) => {
                                              if i.input_len() ==
                                                     input.input_len() {
                                                  break ;
                                              }
                                              res.push(o);
                                              input = i;
                                          }
                                      }
                                  }
                                  match incomplete {
                                      ::std::option::Option::Some(i) =>
                                      ::nom::IResult::Incomplete(i),
                                      ::std::option::Option::None =>
                                      ::nom::IResult::Done(input, res),
                                  }
                              }
                          }
                      }
                  } {
                ::nom::IResult::Done(i, _) => { ::nom::IResult::Done(i, ()) }
                ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                ::nom::IResult::Incomplete(i) =>
                ::nom::IResult::Incomplete(i),
            }
        }
    }
    pub fn number<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], f64, u32>) {
        let result =
            {
                match {
                          match {
                                    {
                                        match {
                                                  let (tmp, res) =
                                                      self.recognize_number1(i);
                                                  self = tmp;
                                                  res
                                              } {
                                            ::nom::IResult::Done(i, o) =>
                                            ::nom::IResult::Done(i,
                                                                 Calculator::stringify_u8(o)),
                                            ::nom::IResult::Incomplete(x) =>
                                            ::nom::IResult::Incomplete(x),
                                            ::nom::IResult::Error(_) => {
                                                {
                                                    match {
                                                              let (tmp, res) =
                                                                  self.recognize_number2(i);
                                                              self = tmp;
                                                              res
                                                          } {
                                                        ::nom::IResult::Done(i,
                                                                             o)
                                                        =>
                                                        ::nom::IResult::Done(i,
                                                                             Calculator::prepend_zero(o)),
                                                        ::nom::IResult::Incomplete(x)
                                                        =>
                                                        ::nom::IResult::Incomplete(x),
                                                        ::nom::IResult::Error(_)
                                                        => {
                                                            ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Alt,
                                                                                                       i))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } {
                              ::nom::IResult::Error(e) =>
                              ::nom::IResult::Error(e),
                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                              =>
                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                              =>
                              ::nom::IResult::Incomplete(::nom::Needed::Size(i)),
                              ::nom::IResult::Done(i, o) =>
                              match (|a: Result<String, str::Utf8Error>|
                                         Ok(match a {
                                                ::std::result::Result::Ok(val)
                                                => val,
                                                ::std::result::Result::Err(err)
                                                => {
                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                }
                                            }.replace('_', "")) as
                                             Result<String,
                                                    str::Utf8Error>)(o) {
                                  Ok(output) =>
                                  ::nom::IResult::Done(i, output),
                                  Err(_) =>
                                  ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::MapRes,
                                                                             i)),
                              },
                          }
                      } {
                    ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                    ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                    ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                    ::nom::IResult::Incomplete(::nom::Needed::Size(i)),
                    ::nom::IResult::Done(i, o) =>
                    match (|a: String| a.parse())(o) {
                        Ok(output) => ::nom::IResult::Done(i, output),
                        Err(_) =>
                        ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::MapRes,
                                                                   i)),
                    },
                }
            };
        (self, result)
    }
    /// Look up a numerical constant (unitless)
    pub fn get_numerical_constant(&self, res: &[u8]) -> Option<f64> {
        match &res {
            &b"e" => Some(std::f64::consts::E),
            &b"pi" => Some(std::f64::consts::PI),
            _ => None,
        }
    }
    /// Look up a united value
    pub fn get_unit(&self, res: &[u8]) -> Option<uval::UnitValue> {
        match str::from_utf8(res) { Ok(a) => units::get(a), Err(_) => None, }
    }
    pub fn num_const<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], f64, u32>) {
        let result =
            {
                match alpha(i) {
                    ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                    ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                    ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                    ::nom::IResult::Incomplete(::nom::Needed::Size(i)),
                    ::nom::IResult::Done(i, o) =>
                    match self.get_numerical_constant(o) {
                        ::std::option::Option::Some(output) =>
                        ::nom::IResult::Done(i, output),
                        ::std::option::Option::None =>
                        ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::MapOpt,
                                                                   i)),
                    },
                }
            };
        (self, result)
    }
    pub fn unit_const<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], uval::UnitValue, u32>) {
        let result =
            {
                match {
                          use ::nom::HexDisplay;
                          match {
                                    use ::nom::InputLength;
                                    match {
                                              if i.is_empty() {
                                                  ::nom::IResult::Incomplete::<_,
                                                                               _>(::nom::Needed::Size(1))
                                              } else {
                                                  #[inline(always)]
                                                  fn as_bytes<T: ::nom::AsBytes>(b:
                                                                                     &T)
                                                   -> &[u8] {
                                                      b.as_bytes()
                                                  }
                                                  let expected =
                                                      "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
                                                  let bytes =
                                                      as_bytes(&expected);
                                                  {
                                                      if i.is_empty() {
                                                          ::nom::IResult::Incomplete::<_,
                                                                                       _>(::nom::Needed::Size(1))
                                                      } else {
                                                          let mut found =
                                                              false;
                                                          for &i in bytes {
                                                              if i == i[0] {
                                                                  found =
                                                                      true;
                                                                  break ;
                                                              }
                                                          }
                                                          if found {
                                                              ::nom::IResult::Done(&i[1..],
                                                                                   i[0]
                                                                                       as
                                                                                       char)
                                                          } else {
                                                              ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::OneOf,
                                                                                                         i))
                                                          }
                                                      }
                                                  }
                                              }
                                          } {
                                        ::nom::IResult::Error(_) =>
                                        ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Many1,
                                                                                   i)),
                                        ::nom::IResult::Incomplete(i) =>
                                        ::nom::IResult::Incomplete(i),
                                        ::nom::IResult::Done(i1, o1) => {
                                            if i1.len() == 0 {
                                                ::nom::IResult::Done(i1,
                                                                     <[_]>::into_vec(box
                                                                                         [o1]))
                                            } else {
                                                let mut res =
                                                    ::std::vec::Vec::with_capacity(4);
                                                res.push(o1);
                                                let mut input = i1;
                                                let mut incomplete:
                                                        ::std::option::Option<::nom::Needed> =
                                                    ::std::option::Option::None;
                                                loop  {
                                                    if input.input_len() == 0
                                                       {
                                                        break ;
                                                    }
                                                    match {
                                                              if input.is_empty()
                                                                 {
                                                                  ::nom::IResult::Incomplete::<_,
                                                                                               _>(::nom::Needed::Size(1))
                                                              } else {
                                                                  #[inline(always)]
                                                                  fn as_bytes<T: ::nom::AsBytes>(b:
                                                                                                     &T)
                                                                   -> &[u8] {
                                                                      b.as_bytes()
                                                                  }
                                                                  let expected =
                                                                      "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
                                                                  let bytes =
                                                                      as_bytes(&expected);
                                                                  {
                                                                      if input.is_empty()
                                                                         {
                                                                          ::nom::IResult::Incomplete::<_,
                                                                                                       _>(::nom::Needed::Size(1))
                                                                      } else {
                                                                          let mut found =
                                                                              false;
                                                                          for &i
                                                                              in
                                                                              bytes
                                                                              {
                                                                              if i
                                                                                     ==
                                                                                     input[0]
                                                                                 {
                                                                                  found
                                                                                      =
                                                                                      true;
                                                                                  break
                                                                                      ;
                                                                              }
                                                                          }
                                                                          if found
                                                                             {
                                                                              ::nom::IResult::Done(&input[1..],
                                                                                                   input[0]
                                                                                                       as
                                                                                                       char)
                                                                          } else {
                                                                              ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::OneOf,
                                                                                                                         input))
                                                                          }
                                                                      }
                                                                  }
                                                              }
                                                          } {
                                                        ::nom::IResult::Error(_)
                                                        => {
                                                            break ;
                                                        }
                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                        => {
                                                            incomplete =
                                                                ::std::option::Option::Some(::nom::Needed::Unknown);
                                                            break ;
                                                        }
                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                        => {
                                                            incomplete =
                                                                ::std::option::Option::Some(::nom::Needed::Size(i
                                                                                                                    +
                                                                                                                    (i).input_len()
                                                                                                                    -
                                                                                                                    input.input_len()));
                                                            break ;
                                                        }
                                                        ::nom::IResult::Done(i,
                                                                             o)
                                                        => {
                                                            if i.input_len()
                                                                   ==
                                                                   input.input_len()
                                                               {
                                                                break ;
                                                            }
                                                            res.push(o);
                                                            input = i;
                                                        }
                                                    }
                                                }
                                                match incomplete {
                                                    ::std::option::Option::Some(i)
                                                    =>
                                                    ::nom::IResult::Incomplete(i),
                                                    ::std::option::Option::None
                                                    =>
                                                    ::nom::IResult::Done(input,
                                                                         res),
                                                }
                                            }
                                        }
                                    }
                                } {
                              ::nom::IResult::Done(i, _) => {
                                  let index = (i).offset(i);
                                  ::nom::IResult::Done(i, &(i)[..index])
                              }
                              ::nom::IResult::Error(e) =>
                              return ::nom::IResult::Error(e),
                              ::nom::IResult::Incomplete(i) =>
                              return ::nom::IResult::Incomplete(i),
                          }
                      } {
                    ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                    ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                    ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                    ::nom::IResult::Incomplete(::nom::Needed::Size(i)),
                    ::nom::IResult::Done(i, o) =>
                    match self.get_unit(o) {
                        ::std::option::Option::Some(output) =>
                        ::nom::IResult::Done(i, output),
                        ::std::option::Option::None =>
                        ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::MapOpt,
                                                                   i)),
                    },
                }
            };
        (self, result)
    }
    pub fn atom<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], Expression, u32>) {
        let result =
            {
                {
                    let res =
                        { let (tmp, res) = self.parens(i); self = tmp; res };
                    match res {
                        ::nom::IResult::Done(_, _) => res,
                        ::nom::IResult::Incomplete(_) => res,
                        _ => {
                            match {
                                      let (tmp, res) = self.number(i);
                                      self = tmp;
                                      res
                                  } {
                                ::nom::IResult::Done(i, o) =>
                                ::nom::IResult::Done(i, input_value(o)),
                                ::nom::IResult::Incomplete(x) =>
                                ::nom::IResult::Incomplete(x),
                                ::nom::IResult::Error(_) => {
                                    {
                                        match {
                                                  let (tmp, res) =
                                                      self.num_const(i);
                                                  self = tmp;
                                                  res
                                              } {
                                            ::nom::IResult::Done(i, o) =>
                                            ::nom::IResult::Done(i,
                                                                 make_value(o)),
                                            ::nom::IResult::Incomplete(x) =>
                                            ::nom::IResult::Incomplete(x),
                                            ::nom::IResult::Error(_) => {
                                                {
                                                    match {
                                                              let (tmp, res) =
                                                                  self.unit_const(i);
                                                              self = tmp;
                                                              res
                                                          } {
                                                        ::nom::IResult::Done(i,
                                                                             o)
                                                        =>
                                                        ::nom::IResult::Done(i,
                                                                             Expression::Value(o)),
                                                        ::nom::IResult::Incomplete(x)
                                                        =>
                                                        ::nom::IResult::Incomplete(x),
                                                        ::nom::IResult::Error(_)
                                                        => {
                                                            ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Alt,
                                                                                                       i))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
    pub fn imul<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], Expression, u32>) {
        let result =
            {
                {
                    use ::nom::InputLength;
                    match { let (tmp, res) = self.atom(i); self = tmp; res } {
                        ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                        ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                           +
                                                                           i)),
                        ::nom::IResult::Done(i, o) => {
                            let first = o;
                            match {
                                      use ::nom::InputLength;
                                      if (i).input_len() == 0 {
                                          ::nom::IResult::Done(i,
                                                               ::std::vec::Vec::new())
                                      } else {
                                          match {
                                                    let (tmp, res) =
                                                        self.atom(i);
                                                    self = tmp;
                                                    res
                                                } {
                                              ::nom::IResult::Error(_) => {
                                                  ::nom::IResult::Done(i,
                                                                       ::std::vec::Vec::new())
                                              }
                                              ::nom::IResult::Incomplete(i) =>
                                              ::nom::IResult::Incomplete(i),
                                              ::nom::IResult::Done(i1, o1) =>
                                              {
                                                  if i1.input_len() == 0 {
                                                      ::nom::IResult::Done(i1,
                                                                           <[_]>::into_vec(box
                                                                                               [o1]))
                                                  } else {
                                                      let mut res =
                                                          ::std::vec::Vec::with_capacity(4);
                                                      res.push(o1);
                                                      let mut input = i1;
                                                      let mut incomplete:
                                                              ::std::option::Option<::nom::Needed> =
                                                          ::std::option::Option::None;
                                                      loop  {
                                                          match {
                                                                    let (tmp,
                                                                         res) =
                                                                        self.atom(input);
                                                                    self =
                                                                        tmp;
                                                                    res
                                                                } {
                                                              ::nom::IResult::Done(i,
                                                                                   o)
                                                              => {
                                                                  if i.input_len()
                                                                         ==
                                                                         input.input_len()
                                                                     {
                                                                      break ;
                                                                  }
                                                                  res.push(o);
                                                                  input = i;
                                                              }
                                                              ::nom::IResult::Error(_)
                                                              => {
                                                                  break ;
                                                              }
                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                              => {
                                                                  incomplete =
                                                                      ::std::option::Option::Some(::nom::Needed::Unknown);
                                                                  break ;
                                                              }
                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                              => {
                                                                  incomplete =
                                                                      ::std::option::Option::Some(::nom::Needed::Size(i
                                                                                                                          +
                                                                                                                          (i).input_len()
                                                                                                                          -
                                                                                                                          input.input_len()));
                                                                  break ;
                                                              }
                                                          }
                                                          if input.input_len()
                                                                 == 0 {
                                                              break ;
                                                          }
                                                      }
                                                      match incomplete {
                                                          ::std::option::Option::Some(i)
                                                          =>
                                                          ::nom::IResult::Incomplete(i),
                                                          ::std::option::Option::None
                                                          =>
                                                          ::nom::IResult::Done(input,
                                                                               res),
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  } {
                                ::nom::IResult::Error(e) =>
                                ::nom::IResult::Error(e),
                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                =>
                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                =>
                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                   +
                                                                                   ((i).input_len()
                                                                                        -
                                                                                        i.input_len())
                                                                                   +
                                                                                   i)),
                                ::nom::IResult::Done(i, o) => {
                                    let others = o;
                                    ::nom::IResult::Done(i,
                                                         (||
                                                              others.into_iter().fold(first,
                                                                                      |lhs,
                                                                                       rhs|
                                                                                          self.simplify1(Expression::Mul(Box::new(lhs),
                                                                                                                         Box::new(rhs)))))())
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
    pub fn unary<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], Expression, u32>) {
        let result =
            {
                {
                    let res =
                        { let (tmp, res) = self.exp(i); self = tmp; res };
                    match res {
                        ::nom::IResult::Done(_, _) => res,
                        ::nom::IResult::Incomplete(_) => res,
                        _ => {
                            match {
                                      {
                                          use ::nom::InputLength;
                                          match {
                                                    {
                                                        use ::nom::InputLength;
                                                        match {
                                                                  {
                                                                      let res =
                                                                          {
                                                                              if i.is_empty()
                                                                                 {
                                                                                  let res:
                                                                                          ::nom::IResult<&[u8],
                                                                                                         char> =
                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                  res
                                                                              } else {
                                                                                  if i[0]
                                                                                         ==
                                                                                         ('+'
                                                                                              as
                                                                                              u8)
                                                                                     {
                                                                                      ::nom::IResult::Done(&i[1..],
                                                                                                           i[0]
                                                                                                               as
                                                                                                               char)
                                                                                  } else {
                                                                                      ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                 i))
                                                                                  }
                                                                              }
                                                                          };
                                                                      match res
                                                                          {
                                                                          ::nom::IResult::Done(_,
                                                                                               _)
                                                                          =>
                                                                          res,
                                                                          ::nom::IResult::Incomplete(_)
                                                                          =>
                                                                          res,
                                                                          _ =>
                                                                          {
                                                                              match {
                                                                                        if i.is_empty()
                                                                                           {
                                                                                            let res:
                                                                                                    ::nom::IResult<&[u8],
                                                                                                                   char> =
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                            res
                                                                                        } else {
                                                                                            if i[0]
                                                                                                   ==
                                                                                                   ('-'
                                                                                                        as
                                                                                                        u8)
                                                                                               {
                                                                                                ::nom::IResult::Done(&i[1..],
                                                                                                                     i[0]
                                                                                                                         as
                                                                                                                         char)
                                                                                            } else {
                                                                                                ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                           i))
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                  {
                                                                                  ::nom::IResult::Done(i,
                                                                                                       o)
                                                                                  =>
                                                                                  ::nom::IResult::Done(i,
                                                                                                       o),
                                                                                  ::nom::IResult::Incomplete(x)
                                                                                  =>
                                                                                  ::nom::IResult::Incomplete(x),
                                                                                  ::nom::IResult::Error(_)
                                                                                  =>
                                                                                  {
                                                                                      ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Alt,
                                                                                                                                 i))
                                                                                  }
                                                                              }
                                                                          }
                                                                      }
                                                                  }
                                                              } {
                                                            ::nom::IResult::Error(e)
                                                            =>
                                                            ::nom::IResult::Error(e),
                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                            =>
                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                            =>
                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                               +
                                                                                                               i)),
                                                            ::nom::IResult::Done(i,
                                                                                 o)
                                                            => {
                                                                let o = o;
                                                                {
                                                                    let res =
                                                                        multispace(i);
                                                                    if let ::nom::IResult::Incomplete(inc)
                                                                           =
                                                                           res
                                                                           {
                                                                        match inc
                                                                            {
                                                                            ::nom::Needed::Unknown
                                                                            =>
                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                            ::nom::Needed::Size(i)
                                                                            =>
                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                               +
                                                                                                                               ((i).input_len()
                                                                                                                                    -
                                                                                                                                    i.input_len())
                                                                                                                               +
                                                                                                                               i)),
                                                                        }
                                                                    } else {
                                                                        let input =
                                                                            if let ::nom::IResult::Done(i,
                                                                                                        _)
                                                                                   =
                                                                                   res
                                                                                   {
                                                                                i
                                                                            } else {
                                                                                i
                                                                            };
                                                                        ::nom::IResult::Done(input,
                                                                                             (||
                                                                                                  o)())
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                } {
                                              ::nom::IResult::Error(e) =>
                                              ::nom::IResult::Error(e),
                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                              =>
                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                              =>
                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                 +
                                                                                                 i)),
                                              ::nom::IResult::Done(i, o) => {
                                                  let op = o;
                                                  match {
                                                            let (tmp, res) =
                                                                self.unary(i);
                                                            self = tmp;
                                                            res
                                                        } {
                                                      ::nom::IResult::Error(e)
                                                      =>
                                                      ::nom::IResult::Error(e),
                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                      =>
                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                      =>
                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         i)),
                                                      ::nom::IResult::Done(i,
                                                                           o)
                                                      => {
                                                          let val = o;
                                                          ::nom::IResult::Done(i,
                                                                               (||
                                                                                    {
                                                                                   match op
                                                                                       {
                                                                                       '+'
                                                                                       =>
                                                                                       val,
                                                                                       '-'
                                                                                       =>
                                                                                       self.simplify1(Expression::Neg(Box::new(val))),
                                                                                       _
                                                                                       =>
                                                                                       val,
                                                                                   }
                                                                               })())
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  } {
                                ::nom::IResult::Done(i, o) =>
                                ::nom::IResult::Done(i, o),
                                ::nom::IResult::Incomplete(x) =>
                                ::nom::IResult::Incomplete(x),
                                ::nom::IResult::Error(_) => {
                                    ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Alt,
                                                                               i))
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
    pub fn exp<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], Expression, u32>) {
        let result =
            {
                {
                    use ::nom::InputLength;
                    match { let (tmp, res) = self.imul(i); self = tmp; res } {
                        ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                        ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                           +
                                                                           i)),
                        ::nom::IResult::Done(i, o) => {
                            let lhs = o;
                            {
                                let res =
                                    {
                                        match {
                                                  {
                                                      use ::nom::InputLength;
                                                      match {
                                                                match {
                                                                          {
                                                                              use ::nom::InputLength;
                                                                              match {
                                                                                        match multispace(i)
                                                                                            {
                                                                                            ::nom::IResult::Done(i,
                                                                                                                 o)
                                                                                            =>
                                                                                            ::nom::IResult::Done(i,
                                                                                                                 ::std::option::Option::Some(o)),
                                                                                            ::nom::IResult::Error(_)
                                                                                            =>
                                                                                            ::nom::IResult::Done(i,
                                                                                                                 ::std::option::Option::None),
                                                                                            ::nom::IResult::Incomplete(i)
                                                                                            =>
                                                                                            ::nom::IResult::Incomplete(i),
                                                                                        }
                                                                                    }
                                                                                  {
                                                                                  ::nom::IResult::Error(e)
                                                                                  =>
                                                                                  ::nom::IResult::Error(e),
                                                                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                  =>
                                                                                  ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                  ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                  =>
                                                                                  ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                     +
                                                                                                                                     i)),
                                                                                  ::nom::IResult::Done(i,
                                                                                                       o)
                                                                                  =>
                                                                                  {
                                                                                      {
                                                                                          use ::nom::InputLength;
                                                                                          match {
                                                                                                    if i.is_empty()
                                                                                                       {
                                                                                                        let res:
                                                                                                                ::nom::IResult<&[u8],
                                                                                                                               char> =
                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                                        res
                                                                                                    } else {
                                                                                                        if i[0]
                                                                                                               ==
                                                                                                               ('^'
                                                                                                                    as
                                                                                                                    u8)
                                                                                                           {
                                                                                                            ::nom::IResult::Done(&i[1..],
                                                                                                                                 i[0]
                                                                                                                                     as
                                                                                                                                     char)
                                                                                                        } else {
                                                                                                            ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                                       i))
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                              {
                                                                                              ::nom::IResult::Error(e)
                                                                                              =>
                                                                                              ::nom::IResult::Error(e),
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                              =>
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                              =>
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                 +
                                                                                                                                                 ((i).input_len()
                                                                                                                                                      -
                                                                                                                                                      i.input_len())
                                                                                                                                                 +
                                                                                                                                                 i)),
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   o)
                                                                                              =>
                                                                                              {
                                                                                                  ::nom::IResult::Done(i,
                                                                                                                       (o,
                                                                                                                        o))
                                                                                              }
                                                                                          }
                                                                                      }
                                                                                  }
                                                                              }
                                                                          }
                                                                      } {
                                                                    ::nom::IResult::Error(a)
                                                                    =>
                                                                    ::nom::IResult::Error(a),
                                                                    ::nom::IResult::Incomplete(i)
                                                                    =>
                                                                    ::nom::IResult::Incomplete(i),
                                                                    ::nom::IResult::Done(remaining,
                                                                                         (_,
                                                                                          o))
                                                                    => {
                                                                        ::nom::IResult::Done(remaining,
                                                                                             o)
                                                                    }
                                                                }
                                                            } {
                                                          ::nom::IResult::Error(e)
                                                          =>
                                                          ::nom::IResult::Error(e),
                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                          =>
                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                          =>
                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                             +
                                                                                                             i)),
                                                          ::nom::IResult::Done(i,
                                                                               o)
                                                          => {
                                                              {
                                                                  use ::nom::InputLength;
                                                                  match {
                                                                            match {
                                                                                      {
                                                                                          use ::nom::InputLength;
                                                                                          match {
                                                                                                    match multispace(i)
                                                                                                        {
                                                                                                        ::nom::IResult::Done(i,
                                                                                                                             o)
                                                                                                        =>
                                                                                                        ::nom::IResult::Done(i,
                                                                                                                             ::std::option::Option::Some(o)),
                                                                                                        ::nom::IResult::Error(_)
                                                                                                        =>
                                                                                                        ::nom::IResult::Done(i,
                                                                                                                             ::std::option::Option::None),
                                                                                                        ::nom::IResult::Incomplete(i)
                                                                                                        =>
                                                                                                        ::nom::IResult::Incomplete(i),
                                                                                                    }
                                                                                                }
                                                                                              {
                                                                                              ::nom::IResult::Error(e)
                                                                                              =>
                                                                                              ::nom::IResult::Error(e),
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                              =>
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                              =>
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                 +
                                                                                                                                                 i)),
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   o)
                                                                                              =>
                                                                                              {
                                                                                                  {
                                                                                                      use ::nom::InputLength;
                                                                                                      match {
                                                                                                                let (tmp,
                                                                                                                     res) =
                                                                                                                    self.unary(i);
                                                                                                                self
                                                                                                                    =
                                                                                                                    tmp;
                                                                                                                res
                                                                                                            }
                                                                                                          {
                                                                                                          ::nom::IResult::Error(e)
                                                                                                          =>
                                                                                                          ::nom::IResult::Error(e),
                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                          =>
                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                          =>
                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                             +
                                                                                                                                                             ((i).input_len()
                                                                                                                                                                  -
                                                                                                                                                                  i.input_len())
                                                                                                                                                             +
                                                                                                                                                             i)),
                                                                                                          ::nom::IResult::Done(i,
                                                                                                                               o)
                                                                                                          =>
                                                                                                          {
                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                   (o,
                                                                                                                                    o))
                                                                                                          }
                                                                                                      }
                                                                                                  }
                                                                                              }
                                                                                          }
                                                                                      }
                                                                                  }
                                                                                {
                                                                                ::nom::IResult::Error(a)
                                                                                =>
                                                                                ::nom::IResult::Error(a),
                                                                                ::nom::IResult::Incomplete(i)
                                                                                =>
                                                                                ::nom::IResult::Incomplete(i),
                                                                                ::nom::IResult::Done(remaining,
                                                                                                     (_,
                                                                                                      o))
                                                                                =>
                                                                                {
                                                                                    ::nom::IResult::Done(remaining,
                                                                                                         o)
                                                                                }
                                                                            }
                                                                        } {
                                                                      ::nom::IResult::Error(e)
                                                                      =>
                                                                      ::nom::IResult::Error(e),
                                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                      =>
                                                                      ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                      =>
                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                         +
                                                                                                                         ((i).input_len()
                                                                                                                              -
                                                                                                                              i.input_len())
                                                                                                                         +
                                                                                                                         i)),
                                                                      ::nom::IResult::Done(i,
                                                                                           o)
                                                                      => {
                                                                          ::nom::IResult::Done(i,
                                                                                               (o,
                                                                                                o))
                                                                      }
                                                                  }
                                                              }
                                                          }
                                                      }
                                                  }
                                              } {
                                            ::nom::IResult::Error(a) =>
                                            ::nom::IResult::Error(a),
                                            ::nom::IResult::Incomplete(i) =>
                                            ::nom::IResult::Incomplete(i),
                                            ::nom::IResult::Done(remaining,
                                                                 (_, o)) => {
                                                ::nom::IResult::Done(remaining,
                                                                     o)
                                            }
                                        }
                                    };
                                if let ::nom::IResult::Incomplete(inc) = res {
                                    match inc {
                                        ::nom::Needed::Unknown =>
                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                        ::nom::Needed::Size(i) =>
                                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                           +
                                                                                           ((i).input_len()
                                                                                                -
                                                                                                i.input_len())
                                                                                           +
                                                                                           i)),
                                    }
                                } else {
                                    let (rhs, input) =
                                        if let ::nom::IResult::Done(i, o) =
                                               res {
                                            (::std::option::Option::Some(o),
                                             i)
                                        } else {
                                            (::std::option::Option::None, i)
                                        };
                                    ::nom::IResult::Done(input,
                                                         (||
                                                              match (lhs, rhs)
                                                                  {
                                                                  (lhs, None)
                                                                  => lhs,
                                                                  (lhs,
                                                                   Some(b)) =>
                                                                  self.simplify1(Expression::Exp(Box::new(lhs),
                                                                                                 Box::new(b))),
                                                              })())
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
    pub fn facterm<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], (char, Expression), u32>) {
        let result =
            {
                {
                    use ::nom::InputLength;
                    match {
                              {
                                  let res =
                                      {
                                          match {
                                                    {
                                                        use ::nom::InputLength;
                                                        match {
                                                                  match multispace(i)
                                                                      {
                                                                      ::nom::IResult::Done(i,
                                                                                           o)
                                                                      =>
                                                                      ::nom::IResult::Done(i,
                                                                                           ::std::option::Option::Some(o)),
                                                                      ::nom::IResult::Error(_)
                                                                      =>
                                                                      ::nom::IResult::Done(i,
                                                                                           ::std::option::Option::None),
                                                                      ::nom::IResult::Incomplete(i)
                                                                      =>
                                                                      ::nom::IResult::Incomplete(i),
                                                                  }
                                                              } {
                                                            ::nom::IResult::Error(e)
                                                            =>
                                                            ::nom::IResult::Error(e),
                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                            =>
                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                            =>
                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                               +
                                                                                                               i)),
                                                            ::nom::IResult::Done(i,
                                                                                 o)
                                                            => {
                                                                {
                                                                    use ::nom::InputLength;
                                                                    match {
                                                                              if i.is_empty()
                                                                                 {
                                                                                  let res:
                                                                                          ::nom::IResult<&[u8],
                                                                                                         char> =
                                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                  res
                                                                              } else {
                                                                                  if i[0]
                                                                                         ==
                                                                                         ('*'
                                                                                              as
                                                                                              u8)
                                                                                     {
                                                                                      ::nom::IResult::Done(&i[1..],
                                                                                                           i[0]
                                                                                                               as
                                                                                                               char)
                                                                                  } else {
                                                                                      ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                 i))
                                                                                  }
                                                                              }
                                                                          } {
                                                                        ::nom::IResult::Error(e)
                                                                        =>
                                                                        ::nom::IResult::Error(e),
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                        =>
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                        =>
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                           +
                                                                                                                           ((i).input_len()
                                                                                                                                -
                                                                                                                                i.input_len())
                                                                                                                           +
                                                                                                                           i)),
                                                                        ::nom::IResult::Done(i,
                                                                                             o)
                                                                        => {
                                                                            ::nom::IResult::Done(i,
                                                                                                 (o,
                                                                                                  o))
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                } {
                                              ::nom::IResult::Error(a) =>
                                              ::nom::IResult::Error(a),
                                              ::nom::IResult::Incomplete(i) =>
                                              ::nom::IResult::Incomplete(i),
                                              ::nom::IResult::Done(remaining,
                                                                   (_, o)) =>
                                              {
                                                  ::nom::IResult::Done(remaining,
                                                                       o)
                                              }
                                          }
                                      };
                                  match res {
                                      ::nom::IResult::Done(_, _) => res,
                                      ::nom::IResult::Incomplete(_) => res,
                                      _ => {
                                          let res =
                                              {
                                                  match {
                                                            {
                                                                use ::nom::InputLength;
                                                                match {
                                                                          match multispace(i)
                                                                              {
                                                                              ::nom::IResult::Done(i,
                                                                                                   o)
                                                                              =>
                                                                              ::nom::IResult::Done(i,
                                                                                                   ::std::option::Option::Some(o)),
                                                                              ::nom::IResult::Error(_)
                                                                              =>
                                                                              ::nom::IResult::Done(i,
                                                                                                   ::std::option::Option::None),
                                                                              ::nom::IResult::Incomplete(i)
                                                                              =>
                                                                              ::nom::IResult::Incomplete(i),
                                                                          }
                                                                      } {
                                                                    ::nom::IResult::Error(e)
                                                                    =>
                                                                    ::nom::IResult::Error(e),
                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                    =>
                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                    =>
                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                       +
                                                                                                                       i)),
                                                                    ::nom::IResult::Done(i,
                                                                                         o)
                                                                    => {
                                                                        {
                                                                            use ::nom::InputLength;
                                                                            match {
                                                                                      if i.is_empty()
                                                                                         {
                                                                                          let res:
                                                                                                  ::nom::IResult<&[u8],
                                                                                                                 char> =
                                                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                          res
                                                                                      } else {
                                                                                          if i[0]
                                                                                                 ==
                                                                                                 ('/'
                                                                                                      as
                                                                                                      u8)
                                                                                             {
                                                                                              ::nom::IResult::Done(&i[1..],
                                                                                                                   i[0]
                                                                                                                       as
                                                                                                                       char)
                                                                                          } else {
                                                                                              ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                         i))
                                                                                          }
                                                                                      }
                                                                                  }
                                                                                {
                                                                                ::nom::IResult::Error(e)
                                                                                =>
                                                                                ::nom::IResult::Error(e),
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                =>
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                =>
                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                   +
                                                                                                                                   ((i).input_len()
                                                                                                                                        -
                                                                                                                                        i.input_len())
                                                                                                                                   +
                                                                                                                                   i)),
                                                                                ::nom::IResult::Done(i,
                                                                                                     o)
                                                                                =>
                                                                                {
                                                                                    ::nom::IResult::Done(i,
                                                                                                         (o,
                                                                                                          o))
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        } {
                                                      ::nom::IResult::Error(a)
                                                      =>
                                                      ::nom::IResult::Error(a),
                                                      ::nom::IResult::Incomplete(i)
                                                      =>
                                                      ::nom::IResult::Incomplete(i),
                                                      ::nom::IResult::Done(remaining,
                                                                           (_,
                                                                            o))
                                                      => {
                                                          ::nom::IResult::Done(remaining,
                                                                               o)
                                                      }
                                                  }
                                              };
                                          match res {
                                              ::nom::IResult::Done(_, _) =>
                                              res,
                                              ::nom::IResult::Incomplete(_) =>
                                              res,
                                              _ => {
                                                  match {
                                                            match {
                                                                      match {
                                                                                {
                                                                                    use ::nom::InputLength;
                                                                                    match multispace(i)
                                                                                        {
                                                                                        ::nom::IResult::Error(e)
                                                                                        =>
                                                                                        ::nom::IResult::Error(e),
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                        =>
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                        =>
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                           +
                                                                                                                                           i)),
                                                                                        ::nom::IResult::Done(i,
                                                                                                             o)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                use ::nom::InputLength;
                                                                                                match {
                                                                                                          let cl =
                                                                                                              ||
                                                                                                                  {
                                                                                                              {
                                                                                                                  match {
                                                                                                                            if i.is_empty()
                                                                                                                               {
                                                                                                                                ::nom::IResult::Incomplete::<_,
                                                                                                                                                             _>(::nom::Needed::Size(1))
                                                                                                                            } else {
                                                                                                                                #[inline(always)]
                                                                                                                                fn as_bytes<T: ::nom::AsBytes>(b:
                                                                                                                                                                   &T)
                                                                                                                                 ->
                                                                                                                                     &[u8] {
                                                                                                                                    b.as_bytes()
                                                                                                                                }
                                                                                                                                let expected =
                                                                                                                                    "+-";
                                                                                                                                let bytes =
                                                                                                                                    as_bytes(&expected);
                                                                                                                                {
                                                                                                                                    if i.is_empty()
                                                                                                                                       {
                                                                                                                                        ::nom::IResult::Incomplete::<_,
                                                                                                                                                                     _>(::nom::Needed::Size(1))
                                                                                                                                    } else {
                                                                                                                                        let mut found =
                                                                                                                                            false;
                                                                                                                                        for &i
                                                                                                                                            in
                                                                                                                                            bytes
                                                                                                                                            {
                                                                                                                                            if i
                                                                                                                                                   ==
                                                                                                                                                   i[0]
                                                                                                                                               {
                                                                                                                                                found
                                                                                                                                                    =
                                                                                                                                                    true;
                                                                                                                                                break
                                                                                                                                                    ;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        if !found
                                                                                                                                           {
                                                                                                                                            ::nom::IResult::Done(&i[1..],
                                                                                                                                                                 i[0]
                                                                                                                                                                     as
                                                                                                                                                                     char)
                                                                                                                                        } else {
                                                                                                                                            ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::NoneOf,
                                                                                                                                                                                       i))
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                      {
                                                                                                                      ::nom::IResult::Done(_,
                                                                                                                                           o)
                                                                                                                      =>
                                                                                                                      ::nom::IResult::Done(i,
                                                                                                                                           o),
                                                                                                                      ::nom::IResult::Error(a)
                                                                                                                      =>
                                                                                                                      ::nom::IResult::Error(a),
                                                                                                                      ::nom::IResult::Incomplete(i)
                                                                                                                      =>
                                                                                                                      ::nom::IResult::Incomplete(i),
                                                                                                                  }
                                                                                                              }
                                                                                                          };
                                                                                                          match cl()
                                                                                                              {
                                                                                                              ::nom::IResult::Incomplete(x)
                                                                                                              =>
                                                                                                              ::nom::IResult::Incomplete(x),
                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                   o)
                                                                                                              =>
                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                   o),
                                                                                                              ::nom::IResult::Error(e)
                                                                                                              =>
                                                                                                              {
                                                                                                                  return ::nom::IResult::Error(::nom::Err::NodePosition(nom::ErrorKind::NoneOf,
                                                                                                                                                                        i,
                                                                                                                                                                        Box::new(e)))
                                                                                                              }
                                                                                                          }
                                                                                                      }
                                                                                                    {
                                                                                                    ::nom::IResult::Error(e)
                                                                                                    =>
                                                                                                    ::nom::IResult::Error(e),
                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                    =>
                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                    =>
                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                       +
                                                                                                                                                       ((i).input_len()
                                                                                                                                                            -
                                                                                                                                                            i.input_len())
                                                                                                                                                       +
                                                                                                                                                       i)),
                                                                                                    ::nom::IResult::Done(i,
                                                                                                                         o)
                                                                                                    =>
                                                                                                    {
                                                                                                        ::nom::IResult::Done(i,
                                                                                                                             (o,
                                                                                                                              o))
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                          {
                                                                          ::nom::IResult::Error(a)
                                                                          =>
                                                                          ::nom::IResult::Error(a),
                                                                          ::nom::IResult::Incomplete(i)
                                                                          =>
                                                                          ::nom::IResult::Incomplete(i),
                                                                          ::nom::IResult::Done(remaining,
                                                                                               (_,
                                                                                                o))
                                                                          => {
                                                                              ::nom::IResult::Done(remaining,
                                                                                                   o)
                                                                          }
                                                                      }
                                                                  } {
                                                                ::nom::IResult::Done(i,
                                                                                     _)
                                                                => {
                                                                    ::nom::IResult::Done(i,
                                                                                         '*')
                                                                }
                                                                ::nom::IResult::Error(e)
                                                                =>
                                                                ::nom::IResult::Error(e),
                                                                ::nom::IResult::Incomplete(i)
                                                                =>
                                                                ::nom::IResult::Incomplete(i),
                                                            }
                                                        } {
                                                      ::nom::IResult::Done(i,
                                                                           o)
                                                      =>
                                                      ::nom::IResult::Done(i,
                                                                           o),
                                                      ::nom::IResult::Incomplete(x)
                                                      =>
                                                      ::nom::IResult::Incomplete(x),
                                                      ::nom::IResult::Error(_)
                                                      => {
                                                          ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Alt,
                                                                                                     i))
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  }
                              }
                          } {
                        ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                        ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                           +
                                                                           i)),
                        ::nom::IResult::Done(i, o) => {
                            {
                                use ::nom::InputLength;
                                match {
                                          match {
                                                    {
                                                        use ::nom::InputLength;
                                                        match {
                                                                  match multispace(i)
                                                                      {
                                                                      ::nom::IResult::Done(i,
                                                                                           o)
                                                                      =>
                                                                      ::nom::IResult::Done(i,
                                                                                           ::std::option::Option::Some(o)),
                                                                      ::nom::IResult::Error(_)
                                                                      =>
                                                                      ::nom::IResult::Done(i,
                                                                                           ::std::option::Option::None),
                                                                      ::nom::IResult::Incomplete(i)
                                                                      =>
                                                                      ::nom::IResult::Incomplete(i),
                                                                  }
                                                              } {
                                                            ::nom::IResult::Error(e)
                                                            =>
                                                            ::nom::IResult::Error(e),
                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                            =>
                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                            =>
                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                               +
                                                                                                               i)),
                                                            ::nom::IResult::Done(i,
                                                                                 o)
                                                            => {
                                                                {
                                                                    use ::nom::InputLength;
                                                                    match {
                                                                              let (tmp,
                                                                                   res) =
                                                                                  self.unary(i);
                                                                              self
                                                                                  =
                                                                                  tmp;
                                                                              res
                                                                          } {
                                                                        ::nom::IResult::Error(e)
                                                                        =>
                                                                        ::nom::IResult::Error(e),
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                        =>
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                        =>
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                           +
                                                                                                                           ((i).input_len()
                                                                                                                                -
                                                                                                                                i.input_len())
                                                                                                                           +
                                                                                                                           i)),
                                                                        ::nom::IResult::Done(i,
                                                                                             o)
                                                                        => {
                                                                            ::nom::IResult::Done(i,
                                                                                                 (o,
                                                                                                  o))
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                } {
                                              ::nom::IResult::Error(a) =>
                                              ::nom::IResult::Error(a),
                                              ::nom::IResult::Incomplete(i) =>
                                              ::nom::IResult::Incomplete(i),
                                              ::nom::IResult::Done(remaining,
                                                                   (_, o)) =>
                                              {
                                                  ::nom::IResult::Done(remaining,
                                                                       o)
                                              }
                                          }
                                      } {
                                    ::nom::IResult::Error(e) =>
                                    ::nom::IResult::Error(e),
                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                    =>
                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                    =>
                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                       +
                                                                                       ((i).input_len()
                                                                                            -
                                                                                            i.input_len())
                                                                                       +
                                                                                       i)),
                                    ::nom::IResult::Done(i, o) => {
                                        ::nom::IResult::Done(i, (o, o))
                                    }
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
    pub fn fac<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], Expression, u32>) {
        let result =
            {
                {
                    use ::nom::InputLength;
                    match { let (tmp, res) = self.unary(i); self = tmp; res }
                        {
                        ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                        ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                           +
                                                                           i)),
                        ::nom::IResult::Done(i, o) => {
                            let first = o;
                            match {
                                      use ::nom::InputLength;
                                      if (i).input_len() == 0 {
                                          ::nom::IResult::Done(i,
                                                               ::std::vec::Vec::new())
                                      } else {
                                          match {
                                                    let (tmp, res) =
                                                        self.facterm(i);
                                                    self = tmp;
                                                    res
                                                } {
                                              ::nom::IResult::Error(_) => {
                                                  ::nom::IResult::Done(i,
                                                                       ::std::vec::Vec::new())
                                              }
                                              ::nom::IResult::Incomplete(i) =>
                                              ::nom::IResult::Incomplete(i),
                                              ::nom::IResult::Done(i1, o1) =>
                                              {
                                                  if i1.input_len() == 0 {
                                                      ::nom::IResult::Done(i1,
                                                                           <[_]>::into_vec(box
                                                                                               [o1]))
                                                  } else {
                                                      let mut res =
                                                          ::std::vec::Vec::with_capacity(4);
                                                      res.push(o1);
                                                      let mut input = i1;
                                                      let mut incomplete:
                                                              ::std::option::Option<::nom::Needed> =
                                                          ::std::option::Option::None;
                                                      loop  {
                                                          match {
                                                                    let (tmp,
                                                                         res) =
                                                                        self.facterm(input);
                                                                    self =
                                                                        tmp;
                                                                    res
                                                                } {
                                                              ::nom::IResult::Done(i,
                                                                                   o)
                                                              => {
                                                                  if i.input_len()
                                                                         ==
                                                                         input.input_len()
                                                                     {
                                                                      break ;
                                                                  }
                                                                  res.push(o);
                                                                  input = i;
                                                              }
                                                              ::nom::IResult::Error(_)
                                                              => {
                                                                  break ;
                                                              }
                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                              => {
                                                                  incomplete =
                                                                      ::std::option::Option::Some(::nom::Needed::Unknown);
                                                                  break ;
                                                              }
                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                              => {
                                                                  incomplete =
                                                                      ::std::option::Option::Some(::nom::Needed::Size(i
                                                                                                                          +
                                                                                                                          (i).input_len()
                                                                                                                          -
                                                                                                                          input.input_len()));
                                                                  break ;
                                                              }
                                                          }
                                                          if input.input_len()
                                                                 == 0 {
                                                              break ;
                                                          }
                                                      }
                                                      match incomplete {
                                                          ::std::option::Option::Some(i)
                                                          =>
                                                          ::nom::IResult::Incomplete(i),
                                                          ::std::option::Option::None
                                                          =>
                                                          ::nom::IResult::Done(input,
                                                                               res),
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  } {
                                ::nom::IResult::Error(e) =>
                                ::nom::IResult::Error(e),
                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                =>
                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                =>
                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                   +
                                                                                   ((i).input_len()
                                                                                        -
                                                                                        i.input_len())
                                                                                   +
                                                                                   i)),
                                ::nom::IResult::Done(i, o) => {
                                    let others = o;
                                    ::nom::IResult::Done(i,
                                                         (||
                                                              others.into_iter().fold(first,
                                                                                      |lhs,
                                                                                       (op,
                                                                                        rhs)|
                                                                                          self.simplify1(match op
                                                                                                             {
                                                                                                             '*'
                                                                                                             =>
                                                                                                             Expression::Mul(Box::new(lhs),
                                                                                                                             Box::new(rhs)),
                                                                                                             '/'
                                                                                                             =>
                                                                                                             Expression::Div(Box::new(lhs),
                                                                                                                             Box::new(rhs)),
                                                                                                             _
                                                                                                             =>
                                                                                                             Expression::Mul(Box::new(lhs),
                                                                                                                             Box::new(rhs)),
                                                                                                         })))())
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
    pub fn expr<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], Expression, u32>) {
        let result =
            {
                {
                    use ::nom::InputLength;
                    match { let (tmp, res) = self.fac(i); self = tmp; res } {
                        ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                        ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                           +
                                                                           i)),
                        ::nom::IResult::Done(i, o) => {
                            let first = o;
                            match {
                                      use ::nom::InputLength;
                                      if (i).input_len() == 0 {
                                          ::nom::IResult::Done(i,
                                                               ::std::vec::Vec::new())
                                      } else {
                                          match {
                                                    {
                                                        use ::nom::InputLength;
                                                        match {
                                                                  match {
                                                                            {
                                                                                use ::nom::InputLength;
                                                                                match {
                                                                                          match multispace(i)
                                                                                              {
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   o)
                                                                                              =>
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   ::std::option::Option::Some(o)),
                                                                                              ::nom::IResult::Error(_)
                                                                                              =>
                                                                                              ::nom::IResult::Done(i,
                                                                                                                   ::std::option::Option::None),
                                                                                              ::nom::IResult::Incomplete(i)
                                                                                              =>
                                                                                              ::nom::IResult::Incomplete(i),
                                                                                          }
                                                                                      }
                                                                                    {
                                                                                    ::nom::IResult::Error(e)
                                                                                    =>
                                                                                    ::nom::IResult::Error(e),
                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                    =>
                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                    =>
                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                       +
                                                                                                                                       i)),
                                                                                    ::nom::IResult::Done(i,
                                                                                                         o)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            use ::nom::InputLength;
                                                                                            match {
                                                                                                      {
                                                                                                          let res =
                                                                                                              {
                                                                                                                  if i.is_empty()
                                                                                                                     {
                                                                                                                      let res:
                                                                                                                              ::nom::IResult<&[u8],
                                                                                                                                             char> =
                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                                                      res
                                                                                                                  } else {
                                                                                                                      if i[0]
                                                                                                                             ==
                                                                                                                             ('+'
                                                                                                                                  as
                                                                                                                                  u8)
                                                                                                                         {
                                                                                                                          ::nom::IResult::Done(&i[1..],
                                                                                                                                               i[0]
                                                                                                                                                   as
                                                                                                                                                   char)
                                                                                                                      } else {
                                                                                                                          ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                                                     i))
                                                                                                                      }
                                                                                                                  }
                                                                                                              };
                                                                                                          match res
                                                                                                              {
                                                                                                              ::nom::IResult::Done(_,
                                                                                                                                   _)
                                                                                                              =>
                                                                                                              res,
                                                                                                              ::nom::IResult::Incomplete(_)
                                                                                                              =>
                                                                                                              res,
                                                                                                              _
                                                                                                              =>
                                                                                                              {
                                                                                                                  match {
                                                                                                                            if i.is_empty()
                                                                                                                               {
                                                                                                                                let res:
                                                                                                                                        ::nom::IResult<&[u8],
                                                                                                                                                       char> =
                                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                                                                res
                                                                                                                            } else {
                                                                                                                                if i[0]
                                                                                                                                       ==
                                                                                                                                       ('-'
                                                                                                                                            as
                                                                                                                                            u8)
                                                                                                                                   {
                                                                                                                                    ::nom::IResult::Done(&i[1..],
                                                                                                                                                         i[0]
                                                                                                                                                             as
                                                                                                                                                             char)
                                                                                                                                } else {
                                                                                                                                    ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                                                               i))
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                      {
                                                                                                                      ::nom::IResult::Done(i,
                                                                                                                                           o)
                                                                                                                      =>
                                                                                                                      ::nom::IResult::Done(i,
                                                                                                                                           o),
                                                                                                                      ::nom::IResult::Incomplete(x)
                                                                                                                      =>
                                                                                                                      ::nom::IResult::Incomplete(x),
                                                                                                                      ::nom::IResult::Error(_)
                                                                                                                      =>
                                                                                                                      {
                                                                                                                          ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Alt,
                                                                                                                                                                     i))
                                                                                                                      }
                                                                                                                  }
                                                                                                              }
                                                                                                          }
                                                                                                      }
                                                                                                  }
                                                                                                {
                                                                                                ::nom::IResult::Error(e)
                                                                                                =>
                                                                                                ::nom::IResult::Error(e),
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                =>
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                =>
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                   +
                                                                                                                                                   ((i).input_len()
                                                                                                                                                        -
                                                                                                                                                        i.input_len())
                                                                                                                                                   +
                                                                                                                                                   i)),
                                                                                                ::nom::IResult::Done(i,
                                                                                                                     o)
                                                                                                =>
                                                                                                {
                                                                                                    ::nom::IResult::Done(i,
                                                                                                                         (o,
                                                                                                                          o))
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        } {
                                                                      ::nom::IResult::Error(a)
                                                                      =>
                                                                      ::nom::IResult::Error(a),
                                                                      ::nom::IResult::Incomplete(i)
                                                                      =>
                                                                      ::nom::IResult::Incomplete(i),
                                                                      ::nom::IResult::Done(remaining,
                                                                                           (_,
                                                                                            o))
                                                                      => {
                                                                          ::nom::IResult::Done(remaining,
                                                                                               o)
                                                                      }
                                                                  }
                                                              } {
                                                            ::nom::IResult::Error(e)
                                                            =>
                                                            ::nom::IResult::Error(e),
                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                            =>
                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                            =>
                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                               +
                                                                                                               i)),
                                                            ::nom::IResult::Done(i,
                                                                                 o)
                                                            => {
                                                                {
                                                                    use ::nom::InputLength;
                                                                    match {
                                                                              match {
                                                                                        {
                                                                                            use ::nom::InputLength;
                                                                                            match {
                                                                                                      match multispace(i)
                                                                                                          {
                                                                                                          ::nom::IResult::Done(i,
                                                                                                                               o)
                                                                                                          =>
                                                                                                          ::nom::IResult::Done(i,
                                                                                                                               ::std::option::Option::Some(o)),
                                                                                                          ::nom::IResult::Error(_)
                                                                                                          =>
                                                                                                          ::nom::IResult::Done(i,
                                                                                                                               ::std::option::Option::None),
                                                                                                          ::nom::IResult::Incomplete(i)
                                                                                                          =>
                                                                                                          ::nom::IResult::Incomplete(i),
                                                                                                      }
                                                                                                  }
                                                                                                {
                                                                                                ::nom::IResult::Error(e)
                                                                                                =>
                                                                                                ::nom::IResult::Error(e),
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                =>
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                =>
                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                   +
                                                                                                                                                   i)),
                                                                                                ::nom::IResult::Done(i,
                                                                                                                     o)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        use ::nom::InputLength;
                                                                                                        match {
                                                                                                                  let (tmp,
                                                                                                                       res) =
                                                                                                                      self.fac(i);
                                                                                                                  self
                                                                                                                      =
                                                                                                                      tmp;
                                                                                                                  res
                                                                                                              }
                                                                                                            {
                                                                                                            ::nom::IResult::Error(e)
                                                                                                            =>
                                                                                                            ::nom::IResult::Error(e),
                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                            =>
                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                            =>
                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                               +
                                                                                                                                                               ((i).input_len()
                                                                                                                                                                    -
                                                                                                                                                                    i.input_len())
                                                                                                                                                               +
                                                                                                                                                               i)),
                                                                                                            ::nom::IResult::Done(i,
                                                                                                                                 o)
                                                                                                            =>
                                                                                                            {
                                                                                                                ::nom::IResult::Done(i,
                                                                                                                                     (o,
                                                                                                                                      o))
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                  {
                                                                                  ::nom::IResult::Error(a)
                                                                                  =>
                                                                                  ::nom::IResult::Error(a),
                                                                                  ::nom::IResult::Incomplete(i)
                                                                                  =>
                                                                                  ::nom::IResult::Incomplete(i),
                                                                                  ::nom::IResult::Done(remaining,
                                                                                                       (_,
                                                                                                        o))
                                                                                  =>
                                                                                  {
                                                                                      ::nom::IResult::Done(remaining,
                                                                                                           o)
                                                                                  }
                                                                              }
                                                                          } {
                                                                        ::nom::IResult::Error(e)
                                                                        =>
                                                                        ::nom::IResult::Error(e),
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                        =>
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                        =>
                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                           +
                                                                                                                           ((i).input_len()
                                                                                                                                -
                                                                                                                                i.input_len())
                                                                                                                           +
                                                                                                                           i)),
                                                                        ::nom::IResult::Done(i,
                                                                                             o)
                                                                        => {
                                                                            ::nom::IResult::Done(i,
                                                                                                 (o,
                                                                                                  o))
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                } {
                                              ::nom::IResult::Error(_) => {
                                                  ::nom::IResult::Done(i,
                                                                       ::std::vec::Vec::new())
                                              }
                                              ::nom::IResult::Incomplete(i) =>
                                              ::nom::IResult::Incomplete(i),
                                              ::nom::IResult::Done(i1, o1) =>
                                              {
                                                  if i1.input_len() == 0 {
                                                      ::nom::IResult::Done(i1,
                                                                           <[_]>::into_vec(box
                                                                                               [o1]))
                                                  } else {
                                                      let mut res =
                                                          ::std::vec::Vec::with_capacity(4);
                                                      res.push(o1);
                                                      let mut input = i1;
                                                      let mut incomplete:
                                                              ::std::option::Option<::nom::Needed> =
                                                          ::std::option::Option::None;
                                                      loop  {
                                                          match {
                                                                    {
                                                                        use ::nom::InputLength;
                                                                        match {
                                                                                  match {
                                                                                            {
                                                                                                use ::nom::InputLength;
                                                                                                match {
                                                                                                          match multispace(input)
                                                                                                              {
                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                   o)
                                                                                                              =>
                                                                                                              ::nom::IResult::Done(i,
                                                                                                                                   ::std::option::Option::Some(o)),
                                                                                                              ::nom::IResult::Error(_)
                                                                                                              =>
                                                                                                              ::nom::IResult::Done(input,
                                                                                                                                   ::std::option::Option::None),
                                                                                                              ::nom::IResult::Incomplete(i)
                                                                                                              =>
                                                                                                              ::nom::IResult::Incomplete(i),
                                                                                                          }
                                                                                                      }
                                                                                                    {
                                                                                                    ::nom::IResult::Error(e)
                                                                                                    =>
                                                                                                    ::nom::IResult::Error(e),
                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                    =>
                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                    =>
                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                       +
                                                                                                                                                       i)),
                                                                                                    ::nom::IResult::Done(i,
                                                                                                                         o)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            use ::nom::InputLength;
                                                                                                            match {
                                                                                                                      {
                                                                                                                          let res =
                                                                                                                              {
                                                                                                                                  if i.is_empty()
                                                                                                                                     {
                                                                                                                                      let res:
                                                                                                                                              ::nom::IResult<&[u8],
                                                                                                                                                             char> =
                                                                                                                                          ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                                                                      res
                                                                                                                                  } else {
                                                                                                                                      if i[0]
                                                                                                                                             ==
                                                                                                                                             ('+'
                                                                                                                                                  as
                                                                                                                                                  u8)
                                                                                                                                         {
                                                                                                                                          ::nom::IResult::Done(&i[1..],
                                                                                                                                                               i[0]
                                                                                                                                                                   as
                                                                                                                                                                   char)
                                                                                                                                      } else {
                                                                                                                                          ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                                                                     i))
                                                                                                                                      }
                                                                                                                                  }
                                                                                                                              };
                                                                                                                          match res
                                                                                                                              {
                                                                                                                              ::nom::IResult::Done(_,
                                                                                                                                                   _)
                                                                                                                              =>
                                                                                                                              res,
                                                                                                                              ::nom::IResult::Incomplete(_)
                                                                                                                              =>
                                                                                                                              res,
                                                                                                                              _
                                                                                                                              =>
                                                                                                                              {
                                                                                                                                  match {
                                                                                                                                            if i.is_empty()
                                                                                                                                               {
                                                                                                                                                let res:
                                                                                                                                                        ::nom::IResult<&[u8],
                                                                                                                                                                       char> =
                                                                                                                                                    ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                                                                                                res
                                                                                                                                            } else {
                                                                                                                                                if i[0]
                                                                                                                                                       ==
                                                                                                                                                       ('-'
                                                                                                                                                            as
                                                                                                                                                            u8)
                                                                                                                                                   {
                                                                                                                                                    ::nom::IResult::Done(&i[1..],
                                                                                                                                                                         i[0]
                                                                                                                                                                             as
                                                                                                                                                                             char)
                                                                                                                                                } else {
                                                                                                                                                    ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                                                                                               i))
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                      {
                                                                                                                                      ::nom::IResult::Done(i,
                                                                                                                                                           o)
                                                                                                                                      =>
                                                                                                                                      ::nom::IResult::Done(i,
                                                                                                                                                           o),
                                                                                                                                      ::nom::IResult::Incomplete(x)
                                                                                                                                      =>
                                                                                                                                      ::nom::IResult::Incomplete(x),
                                                                                                                                      ::nom::IResult::Error(_)
                                                                                                                                      =>
                                                                                                                                      {
                                                                                                                                          ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Alt,
                                                                                                                                                                                     i))
                                                                                                                                      }
                                                                                                                                  }
                                                                                                                              }
                                                                                                                          }
                                                                                                                      }
                                                                                                                  }
                                                                                                                {
                                                                                                                ::nom::IResult::Error(e)
                                                                                                                =>
                                                                                                                ::nom::IResult::Error(e),
                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                =>
                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                =>
                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                   +
                                                                                                                                                                   ((input).input_len()
                                                                                                                                                                        -
                                                                                                                                                                        i.input_len())
                                                                                                                                                                   +
                                                                                                                                                                   i)),
                                                                                                                ::nom::IResult::Done(i,
                                                                                                                                     o)
                                                                                                                =>
                                                                                                                {
                                                                                                                    ::nom::IResult::Done(i,
                                                                                                                                         (o,
                                                                                                                                          o))
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                      {
                                                                                      ::nom::IResult::Error(a)
                                                                                      =>
                                                                                      ::nom::IResult::Error(a),
                                                                                      ::nom::IResult::Incomplete(i)
                                                                                      =>
                                                                                      ::nom::IResult::Incomplete(i),
                                                                                      ::nom::IResult::Done(remaining,
                                                                                                           (_,
                                                                                                            o))
                                                                                      =>
                                                                                      {
                                                                                          ::nom::IResult::Done(remaining,
                                                                                                               o)
                                                                                      }
                                                                                  }
                                                                              }
                                                                            {
                                                                            ::nom::IResult::Error(e)
                                                                            =>
                                                                            ::nom::IResult::Error(e),
                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                            =>
                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                            =>
                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                               +
                                                                                                                               i)),
                                                                            ::nom::IResult::Done(i,
                                                                                                 o)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    use ::nom::InputLength;
                                                                                    match {
                                                                                              match {
                                                                                                        {
                                                                                                            use ::nom::InputLength;
                                                                                                            match {
                                                                                                                      match multispace(i)
                                                                                                                          {
                                                                                                                          ::nom::IResult::Done(i,
                                                                                                                                               o)
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Done(i,
                                                                                                                                               ::std::option::Option::Some(o)),
                                                                                                                          ::nom::IResult::Error(_)
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Done(i,
                                                                                                                                               ::std::option::Option::None),
                                                                                                                          ::nom::IResult::Incomplete(i)
                                                                                                                          =>
                                                                                                                          ::nom::IResult::Incomplete(i),
                                                                                                                      }
                                                                                                                  }
                                                                                                                {
                                                                                                                ::nom::IResult::Error(e)
                                                                                                                =>
                                                                                                                ::nom::IResult::Error(e),
                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                =>
                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                =>
                                                                                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                   +
                                                                                                                                                                   i)),
                                                                                                                ::nom::IResult::Done(i,
                                                                                                                                     o)
                                                                                                                =>
                                                                                                                {
                                                                                                                    {
                                                                                                                        use ::nom::InputLength;
                                                                                                                        match {
                                                                                                                                  let (tmp,
                                                                                                                                       res) =
                                                                                                                                      self.fac(i);
                                                                                                                                  self
                                                                                                                                      =
                                                                                                                                      tmp;
                                                                                                                                  res
                                                                                                                              }
                                                                                                                            {
                                                                                                                            ::nom::IResult::Error(e)
                                                                                                                            =>
                                                                                                                            ::nom::IResult::Error(e),
                                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                                                            =>
                                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                                                            =>
                                                                                                                            ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                                                               +
                                                                                                                                                                               ((i).input_len()
                                                                                                                                                                                    -
                                                                                                                                                                                    i.input_len())
                                                                                                                                                                               +
                                                                                                                                                                               i)),
                                                                                                                            ::nom::IResult::Done(i,
                                                                                                                                                 o)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                ::nom::IResult::Done(i,
                                                                                                                                                     (o,
                                                                                                                                                      o))
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                  {
                                                                                                  ::nom::IResult::Error(a)
                                                                                                  =>
                                                                                                  ::nom::IResult::Error(a),
                                                                                                  ::nom::IResult::Incomplete(i)
                                                                                                  =>
                                                                                                  ::nom::IResult::Incomplete(i),
                                                                                                  ::nom::IResult::Done(remaining,
                                                                                                                       (_,
                                                                                                                        o))
                                                                                                  =>
                                                                                                  {
                                                                                                      ::nom::IResult::Done(remaining,
                                                                                                                           o)
                                                                                                  }
                                                                                              }
                                                                                          }
                                                                                        {
                                                                                        ::nom::IResult::Error(e)
                                                                                        =>
                                                                                        ::nom::IResult::Error(e),
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                                                        =>
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                                                        =>
                                                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                                                           +
                                                                                                                                           ((input).input_len()
                                                                                                                                                -
                                                                                                                                                i.input_len())
                                                                                                                                           +
                                                                                                                                           i)),
                                                                                        ::nom::IResult::Done(i,
                                                                                                             o)
                                                                                        =>
                                                                                        {
                                                                                            ::nom::IResult::Done(i,
                                                                                                                 (o,
                                                                                                                  o))
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                } {
                                                              ::nom::IResult::Done(i,
                                                                                   o)
                                                              => {
                                                                  if i.input_len()
                                                                         ==
                                                                         input.input_len()
                                                                     {
                                                                      break ;
                                                                  }
                                                                  res.push(o);
                                                                  input = i;
                                                              }
                                                              ::nom::IResult::Error(_)
                                                              => {
                                                                  break ;
                                                              }
                                                              ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                              => {
                                                                  incomplete =
                                                                      ::std::option::Option::Some(::nom::Needed::Unknown);
                                                                  break ;
                                                              }
                                                              ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                              => {
                                                                  incomplete =
                                                                      ::std::option::Option::Some(::nom::Needed::Size(i
                                                                                                                          +
                                                                                                                          (i).input_len()
                                                                                                                          -
                                                                                                                          input.input_len()));
                                                                  break ;
                                                              }
                                                          }
                                                          if input.input_len()
                                                                 == 0 {
                                                              break ;
                                                          }
                                                      }
                                                      match incomplete {
                                                          ::std::option::Option::Some(i)
                                                          =>
                                                          ::nom::IResult::Incomplete(i),
                                                          ::std::option::Option::None
                                                          =>
                                                          ::nom::IResult::Done(input,
                                                                               res),
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  } {
                                ::nom::IResult::Error(e) =>
                                ::nom::IResult::Error(e),
                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                =>
                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                =>
                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                   +
                                                                                   ((i).input_len()
                                                                                        -
                                                                                        i.input_len())
                                                                                   +
                                                                                   i)),
                                ::nom::IResult::Done(i, o) => {
                                    let others = o;
                                    ::nom::IResult::Done(i,
                                                         (||
                                                              others.into_iter().fold(first,
                                                                                      |lhs,
                                                                                       (op,
                                                                                        rhs)|
                                                                                          self.simplify1(match op
                                                                                                             {
                                                                                                             '+'
                                                                                                             =>
                                                                                                             Expression::Add(Box::new(lhs),
                                                                                                                             Box::new(rhs)),
                                                                                                             '-'
                                                                                                             =>
                                                                                                             Expression::Sub(Box::new(lhs),
                                                                                                                             Box::new(rhs)),
                                                                                                             _
                                                                                                             =>
                                                                                                             Expression::Add(Box::new(lhs),
                                                                                                                             Box::new(rhs)),
                                                                                                         })))())
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
    pub fn input<'a>(self: Calculator, i: &'a [u8])
     -> (Calculator, ::nom::IResult<&'a [u8], Expression, u32>) {
        let result =
            {
                {
                    use ::nom::InputLength;
                    match {
                              match multispace(i) {
                                  ::nom::IResult::Done(i, o) =>
                                  ::nom::IResult::Done(i,
                                                       ::std::option::Option::Some(o)),
                                  ::nom::IResult::Error(_) =>
                                  ::nom::IResult::Done(i,
                                                       ::std::option::Option::None),
                                  ::nom::IResult::Incomplete(i) =>
                                  ::nom::IResult::Incomplete(i),
                              }
                          } {
                        ::nom::IResult::Error(e) => ::nom::IResult::Error(e),
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                        ::nom::IResult::Incomplete(::nom::Needed::Size(i)) =>
                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                           +
                                                                           i)),
                        ::nom::IResult::Done(i, _) => {
                            {
                                use ::nom::InputLength;
                                match {
                                          let (tmp, res) = self.expr(i);
                                          self = tmp;
                                          res
                                      } {
                                    ::nom::IResult::Error(e) =>
                                    ::nom::IResult::Error(e),
                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                    =>
                                    ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                    ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                    =>
                                    ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                       +
                                                                                       ((i).input_len()
                                                                                            -
                                                                                            i.input_len())
                                                                                       +
                                                                                       i)),
                                    ::nom::IResult::Done(i, o) => {
                                        let res = o;
                                        {
                                            use ::nom::InputLength;
                                            match {
                                                      match multispace(i) {
                                                          ::nom::IResult::Done(i,
                                                                               o)
                                                          =>
                                                          ::nom::IResult::Done(i,
                                                                               ::std::option::Option::Some(o)),
                                                          ::nom::IResult::Error(_)
                                                          =>
                                                          ::nom::IResult::Done(i,
                                                                               ::std::option::Option::None),
                                                          ::nom::IResult::Incomplete(i)
                                                          =>
                                                          ::nom::IResult::Incomplete(i),
                                                      }
                                                  } {
                                                ::nom::IResult::Error(e) =>
                                                ::nom::IResult::Error(e),
                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                =>
                                                ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                =>
                                                ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                   +
                                                                                                   ((i).input_len()
                                                                                                        -
                                                                                                        i.input_len())
                                                                                                   +
                                                                                                   ((i).input_len()
                                                                                                        -
                                                                                                        i.input_len())
                                                                                                   +
                                                                                                   i)),
                                                ::nom::IResult::Done(i, _) =>
                                                {
                                                    match {
                                                              if i.is_empty()
                                                                 {
                                                                  let res:
                                                                          ::nom::IResult<&[u8],
                                                                                         char> =
                                                                      ::nom::IResult::Incomplete(::nom::Needed::Size(1));
                                                                  res
                                                              } else {
                                                                  if i[0] ==
                                                                         ('?'
                                                                              as
                                                                              u8)
                                                                     {
                                                                      ::nom::IResult::Done(&i[1..],
                                                                                           i[0]
                                                                                               as
                                                                                               char)
                                                                  } else {
                                                                      ::nom::IResult::Error(::nom::Err::Position(::nom::ErrorKind::Char,
                                                                                                                 i))
                                                                  }
                                                              }
                                                          } {
                                                        ::nom::IResult::Error(e)
                                                        =>
                                                        ::nom::IResult::Error(e),
                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown)
                                                        =>
                                                        ::nom::IResult::Incomplete(::nom::Needed::Unknown),
                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(i))
                                                        =>
                                                        ::nom::IResult::Incomplete(::nom::Needed::Size(0usize
                                                                                                           +
                                                                                                           ((i).input_len()
                                                                                                                -
                                                                                                                i.input_len())
                                                                                                           +
                                                                                                           ((i).input_len()
                                                                                                                -
                                                                                                                i.input_len())
                                                                                                           +
                                                                                                           ((i).input_len()
                                                                                                                -
                                                                                                                i.input_len())
                                                                                                           +
                                                                                                           i)),
                                                        ::nom::IResult::Done(i,
                                                                             _)
                                                        => {
                                                            ::nom::IResult::Done(i,
                                                                                 (||
                                                                                      {
                                                                                     res
                                                                                 })())
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        (self, result)
    }
}
/// Simplify 1 part of an expression
fn simplify1(expr: Expression) -> Expression {
    /// All values in an array are known
    fn all_known(a: &Vec<Expression>) -> bool {
        a.iter().all(Expression::is_known)
    }
    /// Some value is an error, so we should return an error
    fn any_error(a: &Vec<Expression>) -> bool {
        a.iter().any(Expression::is_error)
    }
    /// Make it more readable by renaming types
    use Expression as E;
    use Expression::Value as V;
    match expr {
        E::Exp(box V(ref a), box V(ref b)) => make_value(a.pow(b)),
        E::Exp(_, box e@E::Error(_)) => e,
        E::Exp(box e@E::Error(_), _) => e,
        E::Mul(box V(ref a), box V(ref b)) => make_value(a.mul(b)),
        E::Mul(_, box e@E::Error(_)) => e,
        E::Mul(box e@E::Error(_), _) => e,
        E::Div(box V(ref a), box V(ref b)) => make_value(a.div(b)),
        E::Div(_, box e@E::Error(_)) => e,
        E::Div(box e@E::Error(_), _) => e,
        E::Add(box V(ref a), box V(ref b)) => make_value(a.add(b)),
        E::Add(_, box e@E::Error(_)) => e,
        E::Add(box e@E::Error(_), _) => e,
        E::Sub(box V(ref a), box V(ref b)) => make_value(a.sub(b)),
        E::Sub(_, box e@E::Error(_)) => e,
        E::Sub(box e@E::Error(_), _) => e,
        E::Neg(box V(a)) => make_value(-a),
        E::Neg(box E::Neg(box a)) => a,
        E::Neg(box e@E::Error(_)) =>
        e,
          /// Call a function by extracting the floating-point values of the arguments
          E::Call(ref f, ref a) if all_known(a) =>
          make_value(f(a.iter().map(Expression::extract_float).collect())),
                                                                           /// Forward the first error
                                                                           E::Call(_,
                                                                                   ref a)
                                                                           if
                                                                           any_error(a)
                                                                           =>
                                                                           match a.iter().find(|e|
                                                                                                   e.is_error()).expect("no error found")
                                                                               {
                                                                               &E::Error(a)
                                                                               =>
                                                                               E::Error(a),
                                                                               _
                                                                               =>
                                                                               {
                                                                                   ::std::rt::begin_unwind("not actually an error",
                                                                                                           {
                                                                                                               static _FILE_LINE:
                                                                                                                      (&'static str,
                                                                                                                       u32)
                                                                                                                      =
                                                                                                                   ("src/main.rs",
                                                                                                                    462u32);
                                                                                                               &_FILE_LINE
                                                                                                           })
                                                                               }
                                                                           },
        expr => expr,
    }
}
/// Main function; we read until we find "quit"
pub fn main() {
    ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                        static __STATIC_FMTSTR:
                                                               &'static [&'static str]
                                                               =
                                                            &["Welcome to Unit Calculator v1.0.0 by James Dong.\n"];
                                                        __STATIC_FMTSTR
                                                    },
                                                    &match () { () => [], }));
    ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                        static __STATIC_FMTSTR:
                                                               &'static [&'static str]
                                                               =
                                                            &["see src/units.rs for a list of units.\n"];
                                                        __STATIC_FMTSTR
                                                    },
                                                    &match () { () => [], }));
    ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                        static __STATIC_FMTSTR:
                                                               &'static [&'static str]
                                                               =
                                                            &["type \"quit\" to quit.\n"];
                                                        __STATIC_FMTSTR
                                                    },
                                                    &match () { () => [], }));
    ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                        static __STATIC_FMTSTR:
                                                               &'static [&'static str]
                                                               =
                                                            &["\n"];
                                                        __STATIC_FMTSTR
                                                    },
                                                    &match () { () => [], }));
    loop  {
        let mut line = String::new();
        ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                            static __STATIC_FMTSTR:
                                                                   &'static [&'static str]
                                                                   =
                                                                &["ucalc> "];
                                                            __STATIC_FMTSTR
                                                        },
                                                        &match () {
                                                             () => [],
                                                         }));
        io::stdout().flush().expect("error flushing");
        io::stdin().read_line(&mut line).expect("error reading");
        if line.trim() == "quit" { break  }
        match Calculator::calculate(line.as_bytes()) {
            Ok(val) =>
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["=> ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&val,) {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Display::fmt)],
                                                             })),
            Err(err) =>
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["error: ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&err,) {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             })),
        }
    }
}
